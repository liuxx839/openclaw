<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI Avatar Lite - çº¯å‰ç«¯ç‰ˆ</title>
    <style>
        * { box-sizing: border-box; }
        
        body { 
            font-family: 'Helvetica Neue', Helvetica, Arial, sans-serif; 
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            background-size: cover;
            background-position: center;
            background-attachment: fixed;
            margin: 0; 
            padding: 20px;
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            color: #fff;
            transition: background 0.3s;
        }

        h1 {
            font-size: 24px;
            margin-bottom: 5px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }
        
        .subtitle {
            font-size: 12px;
            color: #888;
            margin-bottom: 20px;
        }

        /* å¤´åƒå®¹å™¨ - æ›´å¤§å°ºå¯¸ */
        .avatar-container { 
            width: 400px; 
            height: 400px; 
            border-radius: 50%;
            overflow: hidden; 
            position: relative; 
            background: #000;
            box-shadow: 0 20px 60px rgba(0,0,0,0.5);
            margin-bottom: 25px;
            flex-shrink: 0;
        }
        
        .avatar-video { 
            width: 100%; 
            height: 100%; 
            object-fit: cover; 
            position: absolute; 
            top: 0; 
            left: 0; 
        }
        
        .avatar-placeholder {
            width: 100%;
            height: 100%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 100px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        }

        /* è®¾ç½®é¢æ¿ - å¯æŠ˜å  */
        .settings-panel {
            background: rgba(255,255,255,0.1);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 15px;
            margin-bottom: 20px;
            width: 100%;
            max-width: 480px;
            transition: all 0.3s;
        }
        
        .settings-panel.collapsed {
            padding: 10px 15px;
        }
        
        .settings-panel.collapsed .settings-content {
            display: none;
        }
        
        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            cursor: pointer;
        }
        
        .settings-panel h3 {
            margin: 0;
            font-size: 14px;
            color: #aaa;
        }
        
        .toggle-btn {
            background: none;
            border: none;
            color: #888;
            cursor: pointer;
            font-size: 18px;
            padding: 0;
        }
        
        .settings-content {
            margin-top: 15px;
        }
        
        .setting-row {
            display: flex;
            align-items: center;
            margin-bottom: 10px;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .setting-row label {
            min-width: 70px;
            font-size: 13px;
            color: #ccc;
        }
        
        .setting-row input[type="text"],
        .setting-row input[type="password"] {
            flex: 1;
            min-width: 150px;
            padding: 8px 12px;
            border: 1px solid rgba(255,255,255,0.2);
            border-radius: 8px;
            background: rgba(0,0,0,0.3);
            color: #fff;
            font-size: 13px;
        }
        
        .setting-row input:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .btn {
            padding: 8px 16px;
            border: none;
            border-radius: 8px;
            background: #333;
            color: #fff;
            cursor: pointer;
            font-size: 12px;
            transition: background 0.2s;
        }
        
        .btn:hover { background: #555; }
        .btn.primary { background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); }
        .btn.primary:hover { opacity: 0.9; }
        
        .status-badge {
            font-size: 11px;
            padding: 3px 8px;
            border-radius: 10px;
            background: rgba(255,255,255,0.1);
        }
        .status-badge.success { background: rgba(76, 175, 80, 0.3); color: #4CAF50; }
        .status-badge.error { background: rgba(244, 67, 54, 0.3); color: #f44336; }

        .controls { 
            text-align: center;
            width: 100%;
            max-width: 480px;
            margin-bottom: 20px;
        }

        .main-btn { 
            width: 100%;
            padding: 15px 30px; 
            font-size: 16px; 
            border: none; 
            border-radius: 12px; 
            cursor: pointer; 
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white; 
            font-weight: 600; 
            box-shadow: 0 10px 30px rgba(102,126,234,0.3);
            transition: all 0.3s;
        }
        .main-btn:hover { transform: translateY(-2px); }
        .main-btn.active { background: linear-gradient(135deg, #ff416c 0%, #ff4b2b 100%); }
        .main-btn:disabled { background: #444; cursor: not-allowed; }
        
        .status-text { 
            margin-top: 12px; 
            font-size: 13px; 
            color: #888;
        }
        .status-text.connected { color: #4CAF50; }
        .status-text.listening { color: #ffc107; }
        .status-text.error { color: #ff6b6b; }

        .transcript-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            display: none;  /* é»˜è®¤éšè— */
            padding: 15px;
            width: 100%;
            max-width: 480px;
            margin-bottom: 20px;
        }
        
        .transcript-panel h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #888;
        }
        
        .transcript-content {
            font-size: 14px;
            color: #fff;
            min-height: 60px;
            max-height: 150px;
            overflow-y: auto;
            line-height: 1.6;
        }
        .transcript-content .user { color: #667eea; }
        .transcript-content .ai { color: #4CAF50; }
        .transcript-content .system { color: #888; font-style: italic; }

        .memory-panel {
            background: rgba(255,255,255,0.05);
            border-radius: 12px;
            display: none;  /* é»˜è®¤éšè— */
            padding: 15px;
            width: 100%;
            max-width: 480px;
        }
        
        .memory-panel h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #888;
        }
        
        .memory-content {
            font-size: 12px;
            color: #aaa;
            max-height: 100px;
            overflow-y: auto;
            white-space: pre-wrap;
            background: rgba(0,0,0,0.2);
            padding: 10px;
            border-radius: 8px;
        }
        
        .memory-actions {
            margin-top: 10px;
            display: flex;
            gap: 8px;
            flex-wrap: wrap;
        }

        .info-box {
            background: rgba(255,193,7,0.1);
            border: 1px solid rgba(255,193,7,0.3);
            border-radius: 8px;
            padding: 10px 12px;
            margin-bottom: 12px;
            font-size: 11px;
            color: #ffc107;
        }
        .info-box.blue { background: rgba(33,150,243,0.1); border-color: rgba(33,150,243,0.3); color: #64b5f6; }
        .info-box.green { background: rgba(76,175,80,0.1); border-color: rgba(76,175,80,0.3); color: #4CAF50; }

        /* è§†é¢‘å®¹å™¨ */
        #video-container { 
            position: fixed; 
            bottom: 20px; 
            right: 20px; 
            width: 200px; 
            height: 150px; 
            background: #000; 
            border-radius: 12px; 
            overflow: hidden; 
            box-shadow: 0 10px 30px rgba(0,0,0,0.5); 
            opacity: 0; 
            transition: opacity 0.5s ease; 
            z-index: 50; 
            pointer-events: none;
        }
        #video-container.show { opacity: 1; pointer-events: auto; }
        #local-video { width: 100%; height: 100%; object-fit: cover; transform: scaleX(-1); }

        @media (max-width: 520px) {
            body { padding: 15px; }
            .avatar-container { width: 300px; height: 300px; }
            .avatar-placeholder { font-size: 80px; }
            .setting-row { flex-direction: column; align-items: stretch; }
        }
        
        @media (min-width: 800px) {
            .avatar-container { width: 450px; height: 450px; }
        }
    </style>
</head>
<body>

    <h1>AI Avatar Lite</h1>
    <p class="subtitle">çº¯å‰ç«¯ç‰ˆ - å®Œæ•´åŠŸèƒ½</p>

    <div class="avatar-container" id="avatarBox">
        <div class="avatar-placeholder" id="avatarPlaceholder">ğŸ¤–</div>
        <video id="video-idle" class="avatar-video" loop muted playsinline autoplay style="display:none;"></video>
        <video id="video-talk" class="avatar-video" loop muted playsinline style="display:none;"></video>
    </div>

    <div class="settings-panel" id="settingsPanel">
        <div class="settings-header" onclick="toggleSettings()">
            <h3>âš™ï¸ è®¾ç½®</h3>
            <button class="toggle-btn" id="settingsToggle">â–¼</button>
        </div>
        
        <div class="settings-content" id="settingsContent">
            <div class="info-box" id="connectionInfo">
                ğŸ’¡ éœ€ç”¨ç¦ç”¨å®‰å…¨çš„ Chrome: <code>chrome --disable-web-security --user-data-dir=/tmp/dev</code>
            </div>
            
            <div class="setting-row">
                <label>API Key:</label>
                <input type="password" id="apiKeyInput" placeholder="sk-xxxxxxxx">
                <button class="btn" onclick="saveApiKey()">ä¿å­˜</button>
                <span id="apiKeyStatus" class="status-badge"></span>
            </div>
            
            <div class="setting-row">
                <label>çŸ¥è¯†æ–‡ä»¶å¤¹:</label>
                <button class="btn primary" onclick="selectKnowledgeFolder()">ğŸ“ é€‰æ‹©æ–‡ä»¶å¤¹</button>
                <span id="folderStatus" class="status-badge"></span>
            </div>
            
            <div class="setting-row">
                <label>è§†é¢‘æ–‡ä»¶:</label>
                <button class="btn" onclick="selectVideoFiles()">ğŸ¬ é€‰æ‹©è§†é¢‘</button>
                <span id="videoStatus" class="status-badge"></span>
            </div>
            
            <div class="setting-row">
                <label>èƒŒæ™¯å›¾ç‰‡:</label>
                <button class="btn" onclick="selectBackground()">ğŸ–¼ï¸ é€‰æ‹©èƒŒæ™¯</button>
                <button class="btn" onclick="resetBackground()">é‡ç½®</button>
            </div>
        </div>
    </div>

    <div class="controls">
        <button id="toggleBtn" class="main-btn" onclick="toggleSession()" disabled>è¯·å…ˆå®Œæˆè®¾ç½®</button>
        <div id="status" class="status-text">è¯·è¾“å…¥ API Key</div>
        <button class="btn" style="margin-top:10px;" onclick="togglePanels()">ğŸ“‹ æ˜¾ç¤º/éšè—é¢æ¿</button>
    </div>

    <div class="transcript-panel" id="transcriptPanel">
        <h4>ğŸ’¬ å®æ—¶å¯¹è¯ <span id="sessionIndicator" style="float:right;font-size:11px;"></span></h4>
        <div id="transcriptContent" class="transcript-content">ç­‰å¾…å¼€å§‹...</div>
    </div>

    <div class="memory-panel" id="memoryPanel">
        <h4>ğŸ§  çŸ­æœŸè®°å¿† <span id="summaryTimer" style="float:right;font-size:11px;color:#888;"></span></h4>
        <div id="memoryContent" class="memory-content">æš‚æ— è®°å¿†å†…å®¹</div>
        <div class="memory-actions">
            <button class="btn" onclick="refreshMemory()">ğŸ”„ åˆ·æ–°</button>
            <button class="btn" onclick="viewDialogue()">ğŸ“‹ å¯¹è¯</button>
            <button class="btn" onclick="manualSummary()">ğŸ“ ç«‹å³æ€»ç»“</button>
        </div>
    </div>

    <!-- æ‘„åƒå¤´è§†é¢‘ -->
    <div id="video-container">
        <video id="local-video" autoplay muted playsinline></video>
    </div>
    <canvas id="video-canvas" style="display:none;"></canvas>

    <script>
        // ==================== é…ç½® ====================
        const CONFIG = {
            KEEP_ALIVE_TURNS: 5,           // å”¤é†’åä¿æŒçš„å¯¹è¯è½®æ•°
            SUMMARY_INTERVAL: 60000,       // æ€»ç»“é—´éš”ï¼ˆ60ç§’ï¼‰
            SUMMARY_DIALOGUE_COUNT: 50,    // æ€»ç»“æ—¶å–æœ€è¿‘å¤šå°‘æ¡å¯¹è¯
            CONTEXT_REFRESH_INTERVAL: 15000, // ä¸Šä¸‹æ–‡åˆ·æ–°é—´éš”ï¼ˆ15ç§’ï¼‰
        };
        
        // å‘Šåˆ«è¯
        const GOODBYE_WORDS = ["æ‹œæ‹œ", "å¥½äº†", "è°¢è°¢", "å†è§", "åœåœ", "æ²¡äº‹äº†", "å°±è¿™æ ·"];
        
        // å†…ç½®å‘½ä»¤è¯æ˜ å°„ï¼ˆå§‹ç»ˆç”Ÿæ•ˆï¼‰
        const BUILTIN_COMMANDS = {
            "æ‰“å¼€è§†é¢‘": "START_VIDEO",
            "å…³é—­è§†é¢‘": "STOP_VIDEO",
            "æ‹ç…§": "TAKE_PHOTO",
            "åˆç…§": "TAKE_PHOTO",
            "æ‹ä¸€å¼ ": "TAKE_PHOTO",
            "çœ‹çœ‹æˆ‘": "START_VIDEO",
            "åœæ­¢è§†é¢‘": "STOP_VIDEO",
            "å¼€å¯æ‘„åƒå¤´": "START_VIDEO",
            "å…³æ‰æ‘„åƒå¤´": "STOP_VIDEO",
            // å±å¹•å…±äº«å‘½ä»¤
            "æ‰“å¼€å±å¹•": "START_SCREEN",
            "åˆ†äº«å±å¹•": "START_SCREEN",
            "çœ‹æˆ‘å±å¹•": "START_SCREEN",
            "å…³é—­å±å¹•": "STOP_SCREEN",
            "åœæ­¢å±å¹•": "STOP_SCREEN"
        };

        // ==================== çŠ¶æ€å˜é‡ ====================
        let ws = null;
        let audioCtx = null;
        let analyser = null;
        let micProcessor = null;
        let micSource = null;
        let micStream = null;
        let isSessionActive = false;
        let nextPlayTime = 0;
        let activeAudioSources = [];
        
        // ä¼šè¯çŠ¶æ€
        let sessionState = {
            isActive: false,
            remainingTurns: 0,
            lastWakeTime: 0
        };
        
        // éŸ³é¢‘é—¨æ§
        let isGateOpen = false;
        let audioBuffer = [];
        
        // File System Access API
        let knowledgeFolderHandle = null;
        
        // è§†é¢‘
        let talkVideoUrl = null;
        let pauseVideoUrl = null;
        let hasVideos = false;
        let cameraStream = null;
        let screenStream = null;  // å±å¹•æµ
        let videoFrameInterval = null;  // è§†é¢‘å¸§å‘é€å®šæ—¶å™¨
        let currentVideoSource = null;  // 'camera' | 'screen' | null
        
        // çŸ¥è¯†åº“ç¼“å­˜
        let wakeWords = [];
        let responsesJson = {};
        
        // å®šæ—¶å™¨
        let summaryTimer = null;
        let summaryCountdown = CONFIG.SUMMARY_INTERVAL / 1000;
        let contextRefreshTimer = null;
        
        // API Key
        let apiKey = localStorage.getItem('dashscope_api_key') || '';
        
        // DOM
        const videoIdle = document.getElementById('video-idle');
        const videoTalk = document.getElementById('video-talk');
        const avatarPlaceholder = document.getElementById('avatarPlaceholder');
        const toggleBtn = document.getElementById('toggleBtn');
        const statusEl = document.getElementById('status');
        const transcriptContentEl = document.getElementById('transcriptContent');
        const sessionIndicatorEl = document.getElementById('sessionIndicator');
        const summaryTimerEl = document.getElementById('summaryTimer');
        const memoryContentEl = document.getElementById('memoryContent');
        const videoContainer = document.getElementById('video-container');
        const localVideo = document.getElementById('local-video');

        // ==================== åˆå§‹åŒ– ====================
        window.addEventListener('load', async () => {
            if (apiKey) {
                document.getElementById('apiKeyInput').value = apiKey;
                document.getElementById('apiKeyStatus').textContent = 'âœ“';
                document.getElementById('apiKeyStatus').className = 'status-badge success';
            }
            
            // æ¢å¤èƒŒæ™¯å›¾ç‰‡
            const savedBg = localStorage.getItem('background_image');
            if (savedBg) {
                document.body.style.backgroundImage = `url(${savedBg})`;
            }
            
            // å¦‚æœè®¾ç½®å®Œæˆï¼Œè‡ªåŠ¨æŠ˜å è®¾ç½®é¢æ¿
            if (apiKey) {
                setTimeout(() => {
                    collapseSettings();
                }, 500);
            }
            
            checkReadiness();
        });
        
        // ==================== è®¾ç½®é¢æ¿æŠ˜å  ====================
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const toggle = document.getElementById('settingsToggle');
            if (panel.classList.contains('collapsed')) {
                panel.classList.remove('collapsed');
                toggle.textContent = 'â–¼';
            } else {
                panel.classList.add('collapsed');
                toggle.textContent = 'â–¶';
            }
        }
        
        function collapseSettings() {
            const panel = document.getElementById('settingsPanel');
            const toggle = document.getElementById('settingsToggle');
            panel.classList.add('collapsed');
            toggle.textContent = 'â–¶';
        }
        
        // ==================== èƒŒæ™¯é€‰æ‹© ====================
        async function selectBackground() {
            try {
                const [fileHandle] = await window.showOpenFilePicker({
                    types: [{
                        description: 'Images',
                        accept: { 'image/*': ['.jpg', '.jpeg', '.png', '.gif', '.webp'] }
                    }]
                });
                const file = await fileHandle.getFile();
                const reader = new FileReader();
                reader.onload = (e) => {
                    const dataUrl = e.target.result;
                    document.body.style.backgroundImage = `url(${dataUrl})`;
                    localStorage.setItem('background_image', dataUrl);
                };
                reader.readAsDataURL(file);
            } catch (e) {
                if (e.name !== 'AbortError') console.error(e);
            }
        }
        
        function resetBackground() {
            document.body.style.backgroundImage = '';
            localStorage.removeItem('background_image');
        }
        
        // ==================== é¢æ¿æ˜¾ç¤º/éšè— ====================
        let panelsVisible = false;
        
        function togglePanels() {
            panelsVisible = !panelsVisible;
            const transcriptPanel = document.getElementById('transcriptPanel');
            const memoryPanel = document.getElementById('memoryPanel');
            
            if (panelsVisible) {
                transcriptPanel.style.display = 'block';
                memoryPanel.style.display = 'block';
            } else {
                transcriptPanel.style.display = 'none';
                memoryPanel.style.display = 'none';
            }
        }
        
        function saveApiKey() {
            apiKey = document.getElementById('apiKeyInput').value.trim();
            if (apiKey) {
                localStorage.setItem('dashscope_api_key', apiKey);
                document.getElementById('apiKeyStatus').textContent = 'âœ“';
                document.getElementById('apiKeyStatus').className = 'status-badge success';
                checkReadiness();
            }
        }
        
        function checkReadiness() {
            if (apiKey) {
                toggleBtn.disabled = false;
                toggleBtn.textContent = 'ğŸ¤ å¼€å§‹ç›‘å¬';
                statusEl.textContent = 'å‡†å¤‡å°±ç»ª';
            }
        }
        
        // ==================== æ–‡ä»¶æ“ä½œ ====================
        
        async function selectKnowledgeFolder() {
            try {
                if (!('showDirectoryPicker' in window)) {
                    alert('è¯·ä½¿ç”¨ Chrome 86+ æˆ– Edge 86+');
                    return;
                }
                knowledgeFolderHandle = await window.showDirectoryPicker({ mode: 'readwrite' });
                document.getElementById('folderStatus').textContent = 'âœ“ ' + knowledgeFolderHandle.name;
                document.getElementById('folderStatus').className = 'status-badge success';
                
                await ensureKnowledgeFiles();
                await loadKnowledgeBase();
                await refreshMemory();
            } catch (e) {
                if (e.name !== 'AbortError') console.error(e);
            }
        }
        
        async function ensureKnowledgeFiles() {
            const files = ['knowledge.txt', 'raw_material.txt', 'dialogue.txt', 'short_memory.txt', 
                          'long_memory.txt', 'responses.json', 'wake_words.txt', 'commands.txt'];
            for (const f of files) {
                try { await knowledgeFolderHandle.getFileHandle(f); } 
                catch { 
                    const h = await knowledgeFolderHandle.getFileHandle(f, { create: true });
                    if (f === 'responses.json') {
                        const w = await h.createWritable();
                        await w.write('{}');
                        await w.close();
                    } else if (f === 'wake_words.txt') {
                        const w = await h.createWritable();
                        await w.write('å°åŠ©æ‰‹\nä½ å¥½\nå—¨');
                        await w.close();
                    } else if (f === 'commands.txt') {
                        const w = await h.createWritable();
                        await w.write('æ‰“å¼€è§†é¢‘\nå…³é—­è§†é¢‘\næ‹ç…§\nåˆç…§');
                        await w.close();
                    }
                }
            }
        }
        
        async function readFile(filename) {
            if (!knowledgeFolderHandle) return '';
            try {
                const h = await knowledgeFolderHandle.getFileHandle(filename);
                const f = await h.getFile();
                return await f.text();
            } catch { return ''; }
        }
        
        async function writeFile(filename, content) {
            if (!knowledgeFolderHandle) return;
            try {
                const h = await knowledgeFolderHandle.getFileHandle(filename, { create: true });
                const w = await h.createWritable();
                await w.write(content);
                await w.close();
            } catch (e) { console.error('å†™å…¥å¤±è´¥:', filename, e); }
        }
        
        async function appendFile(filename, content) {
            const existing = await readFile(filename);
            await writeFile(filename, existing + content);
        }
        
        async function loadKnowledgeBase() {
            // åŠ è½½å”¤é†’è¯
            const wakeWordsText = await readFile('wake_words.txt');
            wakeWords = wakeWordsText.split('\n').map(w => w.trim()).filter(w => w);
            console.log('å”¤é†’è¯:', wakeWords);
            
            // å‘½ä»¤è¯ä½¿ç”¨å†…ç½®çš„ BUILTIN_COMMANDSï¼Œä¸éœ€è¦è¯»å– commands.txt
            // commands.txt å¯ä»¥ç”¨äºæ‰©å±•ï¼Œä½†ç›®å‰ç›´æ¥ç”¨å†…ç½®çš„
            console.log('å‘½ä»¤è¯:', Object.keys(BUILTIN_COMMANDS));
            
            // åŠ è½½å¿«é€Ÿå›å¤ responses.jsonï¼ˆæ”¯æŒ Python æ ¼å¼ï¼‰
            try {
                const respText = await readFile('responses.json');
                if (respText && respText.trim()) {
                    const rawJson = JSON.parse(respText);
                    
                    // æ£€æµ‹æ ¼å¼ï¼šPythonæ ¼å¼ {KEY: {triggers:[], response:""}} æˆ–ç®€å•æ ¼å¼ {keyword: response}
                    responsesJson = {};
                    for (const [key, value] of Object.entries(rawJson)) {
                        if (value && typeof value === 'object' && value.triggers && value.response) {
                            // Python æ ¼å¼ï¼šæ¯ä¸ª trigger éƒ½æ˜ å°„åˆ°åŒä¸€ä¸ª response
                            for (const trigger of value.triggers) {
                                responsesJson[trigger] = value.response;
                            }
                        } else if (typeof value === 'string') {
                            // ç®€å•æ ¼å¼
                            responsesJson[key] = value;
                        }
                    }
                    console.log('æ ‡å‡†å›å¤ï¼ˆå±•å¼€åï¼‰:', Object.keys(responsesJson).length, 'æ¡');
                    console.log('è§¦å‘è¯:', Object.keys(responsesJson));
                }
            } catch (e) {
                console.error('è§£æ responses.json å¤±è´¥:', e);
            }
        }
        
        async function refreshMemory() {
            const m = await readFile('short_memory.txt');
            memoryContentEl.textContent = m || 'æš‚æ— è®°å¿†';
        }
        
        async function viewDialogue() {
            const d = await readFile('dialogue.txt');
            const lines = d.split('\n').filter(l => l.trim()).slice(-30);
            alert('æœ€è¿‘å¯¹è¯:\n\n' + (lines.join('\n') || 'æš‚æ— '));
        }
        
        // ==================== è§†é¢‘é€‰æ‹© ====================
        
        async function selectVideoFiles() {
            try {
                const files = await window.showOpenFilePicker({
                    multiple: true,
                    types: [{ accept: { 'video/*': ['.mp4', '.webm'] } }]
                });
                let loaded = [];
                for (const h of files) {
                    const f = await h.getFile();
                    const url = URL.createObjectURL(f);
                    const name = f.name.toLowerCase();
                    if (name.includes('talk')) {
                        talkVideoUrl = url;
                        videoTalk.src = url;
                        loaded.push('talk');
                    } else {
                        pauseVideoUrl = url;
                        videoIdle.src = url;
                        loaded.push('idle');
                    }
                }
                if (loaded.length > 0) {
                    hasVideos = true;
                    avatarPlaceholder.style.display = 'none';
                    videoIdle.style.display = 'block';
                    videoIdle.play().catch(() => {});
                    document.getElementById('videoStatus').textContent = 'âœ“';
                    document.getElementById('videoStatus').className = 'status-badge success';
                }
            } catch (e) { if (e.name !== 'AbortError') console.error(e); }
        }
        
        function setAvatarState(state) {
            if (!hasVideos) {
                avatarPlaceholder.textContent = state === 'talking' ? 'ğŸ—£ï¸' : 'ğŸ¤–';
                return;
            }
            if (state === 'talking' && talkVideoUrl) {
                videoIdle.style.display = 'none'; videoIdle.pause();
                videoTalk.style.display = 'block'; videoTalk.play().catch(() => {});
            } else {
                videoTalk.style.display = 'none'; videoTalk.pause();
                videoIdle.style.display = 'block'; videoIdle.play().catch(() => {});
            }
        }
        
        // ==================== ä¼šè¯çŠ¶æ€ç®¡ç† ====================
        
        function activateSession() {
            sessionState.isActive = true;
            sessionState.remainingTurns = CONFIG.KEEP_ALIVE_TURNS;
            sessionState.lastWakeTime = Date.now();
            updateSessionIndicator();
            console.log('ğŸ”” ä¼šè¯æ¿€æ´»ï¼Œä¿æŒ', CONFIG.KEEP_ALIVE_TURNS, 'è½®');
        }
        
        function deactivateSession() {
            sessionState.isActive = false;
            sessionState.remainingTurns = 0;
            isGateOpen = false;
            updateSessionIndicator();
            console.log('ğŸ”• ä¼šè¯å…³é—­');
        }
        
        function consumeTurn() {
            if (sessionState.remainingTurns > 0) {
                sessionState.remainingTurns--;
                updateSessionIndicator();
                console.log('å‰©ä½™è½®æ•°:', sessionState.remainingTurns);
                if (sessionState.remainingTurns <= 0) {
                    deactivateSession();
                }
            }
        }
        
        function updateSessionIndicator() {
            if (sessionState.isActive) {
                sessionIndicatorEl.textContent = `ğŸŸ¢ æ¿€æ´»ä¸­ (${sessionState.remainingTurns}è½®)`;
                sessionIndicatorEl.style.color = '#4CAF50';
            } else {
                sessionIndicatorEl.textContent = 'âšª ç›‘å¬ä¸­';
                sessionIndicatorEl.style.color = '#888';
            }
        }
        
        function isWakeWord(text) {
            return wakeWords.some(w => text.includes(w));
        }
        
        function isGoodbyeWord(text) {
            return GOODBYE_WORDS.some(w => text.includes(w));
        }
        
        function getMatchedCommand(text) {
            for (const [keyword, cmd] of Object.entries(BUILTIN_COMMANDS)) {
                if (text.includes(keyword)) return cmd;
            }
            return null;
        }
        
        function shouldRespond(transcript) {
            // æ£€æŸ¥å‘Šåˆ«è¯
            if (isGoodbyeWord(transcript)) {
                return { respond: true, goodbye: true };
            }
            
            // æ£€æŸ¥å”¤é†’è¯
            if (isWakeWord(transcript)) {
                activateSession();
                return { respond: true, wake: true };
            }
            
            // æ£€æŸ¥å‘½ä»¤è¯
            const cmd = getMatchedCommand(transcript);
            if (cmd) {
                activateSession();
                return { respond: true, command: cmd };
            }
            
            // æ£€æŸ¥æ˜¯å¦åœ¨æ¿€æ´»çŠ¶æ€
            if (sessionState.isActive) {
                return { respond: true, active: true };
            }
            
            return { respond: false };
        }
        
        // ==================== å‘½ä»¤å¤„ç† ====================
        
        async function handleCommand(cmd) {
            console.log('æ‰§è¡Œå‘½ä»¤:', cmd);
            
            if (cmd === 'START_VIDEO') {
                await startCamera();
                addTranscript('system', 'ğŸ“¹ æ‘„åƒå¤´å·²æ‰“å¼€');
            } else if (cmd === 'STOP_VIDEO') {
                stopCamera();
                addTranscript('system', 'ğŸ“¹ æ‘„åƒå¤´å·²å…³é—­');
            } else if (cmd === 'START_SCREEN') {
                const success = await startScreenShare();
                if (success) {
                    addTranscript('system', 'ğŸ–¥ï¸ å±å¹•å…±äº«å·²æ‰“å¼€');
                } else {
                    addTranscript('system', 'âŒ å±å¹•å…±äº«å¤±è´¥æˆ–å·²å–æ¶ˆ');
                }
            } else if (cmd === 'STOP_SCREEN') {
                stopScreenShare();
                addTranscript('system', 'ğŸ–¥ï¸ å±å¹•å…±äº«å·²å…³é—­');
            } else if (cmd === 'TAKE_PHOTO') {
                await takePhoto();
            }
        }
        
        async function startCamera() {
            if (cameraStream) return;
            try {
                cameraStream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 } });
                localVideo.srcObject = cameraStream;
                videoContainer.classList.add('show');
                
                // æ¯ 500ms å‘é€ä¸€å¸§å›¾ç‰‡ï¼ˆ2 fpsï¼‰
                // æ³¨æ„ï¼šå¿…é¡»å…ˆå‘é€è¿‡éŸ³é¢‘æ‰èƒ½å‘é€å›¾ç‰‡
                videoFrameInterval = setInterval(sendVideoFrame, 500);
                console.log('ğŸ“¹ æ‘„åƒå¤´å·²å¼€å¯ï¼Œå¼€å§‹å‘é€è§†é¢‘å¸§');
            } catch (e) { console.error('æ‘„åƒå¤´é”™è¯¯:', e); }
        }
        
        function stopCamera() {
            // åœæ­¢å‘é€è§†é¢‘å¸§
            if (videoFrameInterval) {
                clearInterval(videoFrameInterval);
                videoFrameInterval = null;
            }
            
            if (cameraStream) {
                cameraStream.getTracks().forEach(t => t.stop());
                cameraStream = null;
            }
            localVideo.srcObject = null;
            videoContainer.classList.remove('show');
            currentVideoSource = null;
            console.log('ğŸ“¹ æ‘„åƒå¤´å·²å…³é—­');
        }
        
        // å±å¹•å…±äº«
        async function startScreenShare() {
            // å…ˆå…³é—­æ‘„åƒå¤´å’Œä¹‹å‰çš„å±å¹•å…±äº«
            stopCamera();
            stopScreenShare();
            
            try {
                screenStream = await navigator.mediaDevices.getDisplayMedia({ 
                    video: { 
                        cursor: 'always',
                        width: { ideal: 1280 },
                        height: { ideal: 720 }
                    } 
                });
                
                localVideo.srcObject = screenStream;
                videoContainer.classList.add('show');
                currentVideoSource = 'screen';
                
                // ç›‘å¬ç”¨æˆ·æ‰‹åŠ¨åœæ­¢å…±äº«
                screenStream.getVideoTracks()[0].onended = () => {
                    stopScreenShare();
                    addTranscript('system', 'ğŸ–¥ï¸ å±å¹•å…±äº«å·²åœæ­¢');
                };
                
                // æ¯ 500ms å‘é€ä¸€å¸§å±å¹•æˆªå›¾ï¼ˆ2 fpsï¼‰
                videoFrameInterval = setInterval(sendVideoFrame, 500);
                console.log('ğŸ–¥ï¸ å±å¹•å…±äº«å·²å¼€å¯');
                return true;
            } catch (e) { 
                console.error('å±å¹•å…±äº«é”™è¯¯:', e); 
                return false;
            }
        }
        
        function stopScreenShare() {
            if (screenStream) {
                screenStream.getTracks().forEach(t => t.stop());
                screenStream = null;
            }
            
            if (currentVideoSource === 'screen') {
                // åœæ­¢å‘é€è§†é¢‘å¸§
                if (videoFrameInterval) {
                    clearInterval(videoFrameInterval);
                    videoFrameInterval = null;
                }
                localVideo.srcObject = null;
                videoContainer.classList.remove('show');
                currentVideoSource = null;
                console.log('ğŸ–¥ï¸ å±å¹•å…±äº«å·²å…³é—­');
            }
        }
        
        // å‘é€å›¾ç‰‡å¸§ç»™ Omni
        // å®˜æ–¹æ–‡æ¡£ï¼šinput_image_buffer.append
        // - æ ¼å¼ï¼šJPG/JPEGï¼Œå»ºè®® 480p/720p
        // - å¤§å°ï¼š< 500KB
        // - é¢‘ç‡ï¼š2 fps (500ms)
        // - å¿…é¡»å…ˆå‘é€è¿‡éŸ³é¢‘
        let hasAudioSent = false;  // æ ‡è®°æ˜¯å¦å·²å‘é€è¿‡éŸ³é¢‘
        
        function sendVideoFrame() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            if (!localVideo.videoWidth || !localVideo.videoHeight) return;
            if (!hasAudioSent) return;  // å¿…é¡»å…ˆå‘é€è¿‡éŸ³é¢‘
            
            try {
                const canvas = document.getElementById('video-canvas');
                const ctx = canvas.getContext('2d');
                // ä½¿ç”¨ 480p åˆ†è¾¨ç‡ï¼ˆå®˜æ–¹å»ºè®®ï¼‰
                const targetWidth = 640;
                const targetHeight = 480;
                canvas.width = targetWidth;
                canvas.height = targetHeight;
                ctx.drawImage(localVideo, 0, 0, targetWidth, targetHeight);
                
                // è½¬æˆ JPEG base64ï¼ŒåŠ¨æ€è°ƒæ•´è´¨é‡ç¡®ä¿ < 500KB
                let quality = 0.6;
                let dataURL = canvas.toDataURL('image/jpeg', quality);
                let base64Data = dataURL.split(',')[1];
                
                // æ£€æŸ¥å¤§å°ï¼Œå¦‚æœè¶…è¿‡ 450KB åˆ™é™ä½è´¨é‡ï¼ˆç•™ 50KB ä½™é‡ï¼‰
                const maxSize = 450 * 1024;  // 450KB in bytes
                while (base64Data.length > maxSize && quality > 0.2) {
                    quality -= 0.1;
                    dataURL = canvas.toDataURL('image/jpeg', quality);
                    base64Data = dataURL.split(',')[1];
                }
                
                // ä½¿ç”¨ input_image_buffer.appendï¼ˆå®˜æ–¹æ ¼å¼ï¼‰
                const imageEvent = {
                    type: 'input_image_buffer.append',
                    image: base64Data
                };
                ws.send(JSON.stringify(imageEvent));
            } catch (e) {
                console.error('å‘é€å›¾ç‰‡å¤±è´¥:', e);
            }
        }
        
        async function takePhoto() {
            if (!cameraStream) await startCamera();
            await new Promise(r => setTimeout(r, 500));
            
            const canvas = document.getElementById('video-canvas');
            const ctx = canvas.getContext('2d');
            canvas.width = localVideo.videoWidth;
            canvas.height = localVideo.videoHeight;
            ctx.drawImage(localVideo, 0, 0);
            
            const dataURL = canvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.download = `photo_${Date.now()}.png`;
            link.href = dataURL;
            link.click();
            
            addTranscript('system', 'ğŸ“¸ ç…§ç‰‡å·²ä¿å­˜');
        }
        
        // ==================== å®šæ—¶æ€»ç»“ ====================
        
        function startSummaryTimer() {
            summaryCountdown = CONFIG.SUMMARY_INTERVAL / 1000;
            updateSummaryTimerDisplay();
            
            summaryTimer = setInterval(() => {
                summaryCountdown--;
                updateSummaryTimerDisplay();
                
                if (summaryCountdown <= 0) {
                    generateSummary();
                    summaryCountdown = CONFIG.SUMMARY_INTERVAL / 1000;
                }
            }, 1000);
        }
        
        function stopSummaryTimer() {
            if (summaryTimer) {
                clearInterval(summaryTimer);
                summaryTimer = null;
            }
            summaryTimerEl.textContent = '';
        }
        
        // æ¯15ç§’åˆ·æ–°ä¸Šä¸‹æ–‡
        function startContextRefreshTimer() {
            contextRefreshTimer = setInterval(async () => {
                await refreshContext();
            }, CONFIG.CONTEXT_REFRESH_INTERVAL);
        }
        
        function stopContextRefreshTimer() {
            if (contextRefreshTimer) {
                clearInterval(contextRefreshTimer);
                contextRefreshTimer = null;
            }
        }
        
        async function refreshContext() {
            if (!ws || ws.readyState !== WebSocket.OPEN) return;
            
            console.log('ğŸ”„ åˆ·æ–°ä¸Šä¸‹æ–‡...');
            
            // é‡æ–°åŠ è½½çŸ¥è¯†åº“
            if (knowledgeFolderHandle) {
                await loadKnowledgeBase();
            }
            
            // ç”Ÿæˆæ–°çš„ç³»ç»Ÿæç¤ºè¯
            const systemPrompt = await generateSystemPrompt();
            
            // å‘é€ session.update æ›´æ–°ä¸Šä¸‹æ–‡
            const sessionUpdate = {
                type: 'session.update',
                session: {
                    modalities: ['audio', 'text'],  // video ä¸è¢«æ”¯æŒ
                    voice: 'Serena',
                    instructions: systemPrompt,
                    input_audio_format: 'pcm16',
                    output_audio_format: 'pcm16',
                    turn_detection: { type: 'server_vad' },
                    input_audio_transcription: { model: 'qwen3-asr-flash-realtime' }
                }
            };
            ws.send(JSON.stringify(sessionUpdate));
            console.log('âœ… ä¸Šä¸‹æ–‡å·²åˆ·æ–°');
        }
        
        function updateSummaryTimerDisplay() {
            summaryTimerEl.textContent = `ä¸‹æ¬¡æ€»ç»“: ${summaryCountdown}s`;
        }
        
        async function manualSummary() {
            addTranscript('system', 'ğŸ“ æ­£åœ¨ç”Ÿæˆæ€»ç»“...');
            await generateSummary();
        }
        
        async function generateSummary() {
            console.log('ğŸ”„ å¼€å§‹ç”Ÿæˆæ€»ç»“...');
            addTranscript('system', 'ğŸ“ æ­£åœ¨æ€»ç»“...');
            
            const dialogue = await readFile('dialogue.txt');
            
            // è®¡ç®—å½“å‰æ—¶é—´æ®µ
            const now = new Date();
            const today = now.toISOString().split('T')[0];
            const hour = now.getHours();
            const slotStart = Math.floor(hour / 4) * 4;
            const slotEnd = slotStart + 4;
            
            // åªè¿‡æ»¤å½“å‰æ—¶é—´æ®µçš„å¯¹è¯
            const allLines = dialogue.split('\n').filter(l => l.trim());
            const currentSlotLines = allLines.filter(line => {
                // è§£ææ—¶é—´æˆ³ [YYYY-MM-DD HH:MM:SS]
                const match = line.match(/^\[(\d{4}-\d{2}-\d{2})\s+(\d{2}):/);
                if (!match) return false;
                const lineDate = match[1];
                const lineHour = parseInt(match[2]);
                // åªä¿ç•™ä»Šå¤©ä¸”åœ¨å½“å‰æ—¶é—´æ®µå†…çš„å¯¹è¯
                return lineDate === today && lineHour >= slotStart && lineHour < slotEnd;
            });
            
            console.log(`ğŸ“Š å½“å‰æ—¶é—´æ®µ ${slotStart}:00-${slotEnd}:00ï¼Œå…± ${currentSlotLines.length} æ¡å¯¹è¯`);
            
            // å–æœ€å¤š50æ¡
            const lines = currentSlotLines.slice(-CONFIG.SUMMARY_DIALOGUE_COUNT);
            
            if (lines.length < 3) {
                console.log('å½“å‰æ—¶é—´æ®µå¯¹è¯å¤ªå°‘ï¼Œè·³è¿‡æ€»ç»“');
                addTranscript('system', 'ğŸ“ å½“å‰æ—¶é—´æ®µå¯¹è¯å¤ªå°‘ï¼Œè·³è¿‡æ€»ç»“');
                return;
            }
            
            const currentMemory = await readFile('short_memory.txt');
            const rawMaterial = await readFile('raw_material.txt');
            
            // è°ƒç”¨ qwen-plus ç”Ÿæˆæ€»ç»“ï¼ˆåªæ€»ç»“å½“å‰æ—¶é—´æ®µï¼‰
            const prompt = `ä½ æ˜¯ä¸€ä¸ªå¯¹è¯æ€»ç»“åŠ©æ‰‹ã€‚è¯·æ ¹æ®ä»¥ä¸‹ã€å½“å‰æ—¶é—´æ®µã€‘çš„å¯¹è¯å†…å®¹ï¼Œç”Ÿæˆç®€æ´çš„æ€»ç»“è¦ç‚¹ã€‚

## å½“å‰æ—¶é—´æ®µ
${today} ${slotStart}:00-${slotEnd}:00

## å‚è€ƒèµ„æ–™
${rawMaterial || 'ï¼ˆæ— ï¼‰'}

## å½“å‰æ—¶é—´æ®µçš„å¯¹è¯
${lines.join('\n')}

è¯·åªæ ¹æ®ä¸Šé¢ã€å½“å‰æ—¶é—´æ®µçš„å¯¹è¯ã€‘ç”Ÿæˆæ€»ç»“ï¼Œä¸è¦å‚è€ƒå…¶ä»–æ—¶é—´æ®µçš„å†…å®¹ã€‚
ç”¨ç®€æ´çš„è¦ç‚¹å½¢å¼æ€»ç»“ï¼ˆç”¨æˆ·å…³å¿ƒä»€ä¹ˆã€è®¨è®ºäº†ä»€ä¹ˆè¯é¢˜ï¼‰ã€‚
ä¸è¶…è¿‡5ä¸ªè¦ç‚¹ï¼Œæ¯ä¸ªè¦ç‚¹ä¸€è¡Œã€‚åªè¾“å‡ºæ€»ç»“å†…å®¹ï¼Œä¸è¦å…¶ä»–è¯´æ˜ã€‚`;

            try {
                console.log('ğŸ“¡ è°ƒç”¨ qwen-plus API...');
                const response = await fetch('https://dashscope.aliyuncs.com/api/v1/services/aigc/text-generation/generation', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${apiKey}`
                    },
                    body: JSON.stringify({
                        model: 'qwen-plus',
                        input: {
                            messages: [{ role: 'user', content: prompt }]
                        },
                        parameters: {
                            max_tokens: 500
                        }
                    })
                });
                
                // æ£€æŸ¥å“åº”çŠ¶æ€
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('âŒ API è¯·æ±‚å¤±è´¥:', response.status, errorText.substring(0, 200));
                    addTranscript('system', `ğŸ“ æ€»ç»“å¤±è´¥: HTTP ${response.status}`);
                    return;
                }
                
                // æ£€æŸ¥ Content-Type
                const contentType = response.headers.get('content-type');
                if (!contentType || !contentType.includes('application/json')) {
                    const text = await response.text();
                    console.error('âŒ API è¿”å›é JSON:', contentType, text.substring(0, 200));
                    addTranscript('system', 'ğŸ“ æ€»ç»“å¤±è´¥: API è¿”å›æ ¼å¼é”™è¯¯');
                    return;
                }
                
                const data = await response.json();
                console.log('ğŸ“¥ API å“åº”:', data);
                
                // æ£€æŸ¥ API é”™è¯¯
                if (data.code && data.code !== '200' && data.code !== 200) {
                    console.error('âŒ API ä¸šåŠ¡é”™è¯¯:', data.code, data.message);
                    addTranscript('system', `ğŸ“ æ€»ç»“å¤±è´¥: ${data.message || data.code}`);
                    return;
                }
                
                const summary = data.output?.text || data.output?.choices?.[0]?.message?.content;
                
                if (summary) {
                    // è·å–å½“å‰æ—¶é—´æ®µ
                    const now = new Date();
                    const hour = now.getHours();
                    const slot = Math.floor(hour / 4) * 4;
                    const slotLabel = `${slot}:00-${slot+4}:00`;
                    const dateStr = now.toISOString().split('T')[0];
                    
                    // è§£æç°æœ‰çŸ­æœŸè®°å¿†ï¼Œæ›´æ–°å½“å‰æ—¶é—´æ®µ
                    let newMemory = await updateTimeSlotMemory(currentMemory, dateStr, slotLabel, summary);
                    
                    console.log('ğŸ’¾ å†™å…¥ short_memory.txt:', newMemory.substring(0, 100) + '...');
                    await writeFile('short_memory.txt', newMemory);
                    await refreshMemory();
                    console.log('âœ… æ€»ç»“å·²ä¿å­˜åˆ° short_memory.txt');
                    addTranscript('system', 'ğŸ“ è®°å¿†å·²æ›´æ–°');
                } else {
                    console.error('âŒ API è¿”å›æ— æ•ˆ:', data);
                    addTranscript('system', 'ğŸ“ æ€»ç»“å¤±è´¥: APIè¿”å›æ— æ•ˆ');
                }
            } catch (e) {
                console.error('âŒ æ€»ç»“å¤±è´¥:', e);
                addTranscript('system', 'ğŸ“ æ€»ç»“å¤±è´¥: ' + e.message);
            }
        }
        
        async function updateTimeSlotMemory(currentMemory, dateStr, slotLabel, newSummary) {
            // ç”Ÿæˆæ–‡ä»¶å¤´ï¼ˆå¸¦æ›´æ–°æ—¶é—´ï¼‰
            const now = new Date();
            const updateTime = formatTimestamp(now);
            const fileHeader = `# çŸ­æœŸè®°å¿†
# æœ€åæ›´æ–°ï¼š${updateTime}
# ================================================

`;
            
            // ç®€å•å®ç°ï¼šæŒ‰æ—¥æœŸå’Œæ—¶é—´æ®µç»„ç»‡
            const header = `ã€${dateStr} ${slotLabel}ã€‘`;
            
            // è¿‡æ»¤æ‰æ—§çš„æ–‡ä»¶å¤´ï¼ˆä»¥ # å¼€å¤´çš„è¡Œï¼‰
            const contentLines = currentMemory.split('\n').filter(l => !l.startsWith('#') && l.trim() !== '');
            
            // å¦‚æœå½“å‰è®°å¿†å·²æœ‰è¯¥æ—¶é—´æ®µï¼Œæ›¿æ¢å®ƒ
            let found = false;
            let result = [];
            let skipUntilNext = false;
            
            for (const line of contentLines) {
                if (line.startsWith('ã€') && line.includes(dateStr) && line.includes(slotLabel)) {
                    // æ‰¾åˆ°å½“å‰æ—¶é—´æ®µï¼Œæ›¿æ¢
                    result.push(header);
                    result.push(newSummary.trim());
                    result.push('');
                    found = true;
                    skipUntilNext = true;
                } else if (line.startsWith('ã€')) {
                    skipUntilNext = false;
                    result.push(line);
                } else if (!skipUntilNext) {
                    result.push(line);
                }
            }
            
            if (!found) {
                // æ·»åŠ æ–°æ—¶é—´æ®µ
                result.push(header);
                result.push(newSummary.trim());
                result.push('');
            }
            
            // åŠ ä¸Šæ–‡ä»¶å¤´å¹¶è¿”å›
            return fileHeader + result.join('\n').trim();
        }
        
        // ==================== ç”Ÿæˆç³»ç»Ÿæç¤ºè¯ ====================
        
        async function generateSystemPrompt() {
            const knowledge = await readFile('knowledge.txt');
            const rawMaterial = await readFile('raw_material.txt');
            const shortMemory = await readFile('short_memory.txt');
            const longMemory = await readFile('long_memory.txt');
            const dialogue = await readFile('dialogue.txt');
            
            // è·å–ä»Šå¤©çš„å¯¹è¯ï¼ˆæœ€å¤š200æ¡ï¼‰
            const today = new Date().toISOString().split('T')[0];
            const dialogueLines = dialogue.split('\n').filter(l => l.includes(today)).slice(-200);
            
            // ç”Ÿæˆå›ºå®šé—®ç­”è§„åˆ™ï¼ˆPython æ ¼å¼ï¼‰
            // responsesJson å·²ç»åœ¨ loadKnowledgeBase ä¸­åŠ è½½äº†åŸå§‹æ ¼å¼
            const rawResponses = await readFile('responses.json');
            let presetRules = [];
            try {
                if (rawResponses && rawResponses.trim()) {
                    const rawJson = JSON.parse(rawResponses);
                    for (const [key, item] of Object.entries(rawJson)) {
                        if (item && typeof item === 'object' && item.triggers && item.response) {
                            const triggers = item.triggers.map(t => `"${t}"`).join(', ');
                            presetRules.push(`- å½“ç”¨æˆ·è¯´ ${triggers} æ—¶ -> ä¸¥æ ¼å¤è¯»: "${item.response}"`);
                        }
                    }
                }
            } catch (e) {
                console.error('è§£æ responses.json å¤±è´¥:', e);
            }
            const presetRulesStr = presetRules.length > 0 ? presetRules.join('\n') : 'ï¼ˆæš‚æ— å›ºå®šé—®ç­”é…ç½®ï¼‰';
            
            console.log('ç”Ÿæˆæç¤ºè¯ï¼Œå›ºå®šé—®ç­”è§„åˆ™:', presetRules.length, 'æ¡');
            
            // ä¸ Python ç‰ˆæœ¬ä¿æŒä¸€è‡´çš„ prompt
            let prompt = `ä½ æ˜¯AIåŠ©ç†ï¼Œåå­—å«"å°åŠ©æ‰‹"ã€‚

### æ ¸å¿ƒæŒ‡ä»¤ ###
1. **é™é»˜åŸåˆ™**ï¼šé™¤éå¤„äº"æ¿€æ´»çŠ¶æ€"ï¼Œå¦åˆ™å¯ä»¥æ€è€ƒä½†ä¿æŒå®‰é™ã€‚
2. **å›ç­”åŸåˆ™**ï¼šè¢«å”¤é†’åï¼Œè¯·æ ¹æ®ä»¥ä¸‹åœºæ™¯è§„åˆ™å›ç­”ã€‚
3. **ä¼šè¯ä¿æŒ**ï¼šä¸€æ—¦è¢«å”¤é†’ï¼Œåç»­å‡ è½®å¯¹è¯æ— éœ€å†æ¬¡å”¤é†’ï¼Œç›´åˆ°ç”¨æˆ·è¯´"å†è§"ã€"è°¢è°¢"ç­‰ç»“æŸè¯­ã€‚

### å”¤é†’è¯ ###
${JSON.stringify(wakeWords)}

### æŒ‡ä»¤è¯ ###
${JSON.stringify(Object.keys(BUILTIN_COMMANDS))}

### åœºæ™¯å¤„ç†è§„åˆ™ ###

**åœºæ™¯ Aï¼šã€å›ºå®šé—®ç­”ã€‘** (è§¦å‘æ¡ä»¶å¿…é¡»ä¸¥æ ¼åŒ¹é…ï¼Œå¿…é¡»ä¸¥æ ¼å¤è¯»ï¼Œä¸€å­—ä¸æ”¹)
${presetRulesStr}

**åœºæ™¯ Bï¼šã€æ‹ç…§æŒ‡ä»¤ã€‘**
- å¦‚æœç”¨æˆ·è¦æ±‚"åˆç…§"ã€"æ‹ç…§"ï¼Œè¯·æŒ‰ä»¥ä¸‹æ ¼å¼å›ç­”ï¼š
  1. å…ˆè¯´ï¼š"å¥½çš„ï¼Œå¤§å®¶çœ‹é•œå¤´ï¼å‡†å¤‡å¥½ï¼Œ3ï¼Œ2ï¼Œ1ï¼ŒèŒ„å­ï¼"
  2. **ç´§æ¥ç€**ï¼Œæ ¹æ®ä½ ç°åœ¨çœ‹åˆ°çš„è§†é¢‘ç”»é¢ï¼ŒåŠ ä¸€å¥ç®€çŸ­ã€å¹½é»˜çš„èµç¾æˆ–æè¿°ï¼ˆä¾‹å¦‚ï¼š"å¤§å®¶çš„ç¬‘å®¹çœŸç¿çƒ‚ï¼"ï¼‰ã€‚

**åœºæ™¯ Dï¼šã€æ™®é€šé—²èŠã€‘**
- å¦‚æœç”¨æˆ·åªæ˜¯è¯´"ä½ å¥½"ã€"åœ¨å—"ç­‰ç®€å•é—®å€™ï¼Œè¯·ç”¨**ä¸€å¥è¯äº²åˆ‡å›åº”**ï¼ˆä¾‹å¦‚ï¼š"åœ¨çš„ï¼Œè¯·é—®æœ‰ä»€ä¹ˆå¯ä»¥å¸®æ‚¨ï¼Ÿ"ï¼‰ï¼Œ**ä¸¥ç¦**ä½¿ç”¨é•¿ç¯‡è‡ªæˆ‘ä»‹ç»ã€‚
- å¯¹äºå…¶ä»–ä»»ä½•æœªå‘½ä¸­åœºæ™¯Açš„é—®é¢˜ï¼Œè¯·ç”¨**ä¸“ä¸šã€æ¸©æš–ä¸”æå…¶ç®€çŸ­ï¼ˆ30å­—ä»¥å†…ï¼‰**çš„è¯­è¨€å›ç­”ï¼Œä¸è¦å•°å—¦ã€‚

**åœºæ™¯ Eï¼šã€ç»“æŸå¯¹è¯ã€‘**
- å½“ç”¨æˆ·è¯´"å†è§"ã€"æ‹œæ‹œ"ã€"è°¢è°¢"ã€"æ²¡äº‹äº†"ç­‰ç»“æŸè¯­æ—¶ï¼Œè¯·æ¸©æš–åœ°å‘Šåˆ«ï¼Œå¦‚ï¼š"å¥½çš„ï¼Œæœ‰éœ€è¦éšæ—¶å«æˆ‘ï¼"

**åœºæ™¯ Fï¼šã€åˆ©ç”¨è®°å¿†å›ç­”ã€‘**
- å½“ç”¨æˆ·é—®"åˆšæ‰è¯´äº†ä»€ä¹ˆ"ã€"ä¹‹å‰èŠäº†ä»€ä¹ˆ"ã€"æˆ‘ä»¬è°ˆè¿‡ä»€ä¹ˆ"ç­‰å…³äºä¹‹å‰å¯¹è¯çš„é—®é¢˜æ—¶
- è¯·å‚è€ƒä¸‹æ–¹çš„**çŸ­æœŸè®°å¿†**æ¥å›ç­”ï¼Œè¿™æ˜¯æœ€è¿‘å¯¹è¯çš„æ‘˜è¦
- å½“ç”¨æˆ·é—®åˆ°ä¹‹å‰è®¨è®ºè¿‡çš„è¯é¢˜æ—¶ï¼Œä¹Ÿå¯ä»¥å‚è€ƒçŸ­æœŸè®°å¿†å’Œé•¿æœŸè®°å¿†ä¸­çš„ä¿¡æ¯

### èƒŒæ™¯çŸ¥è¯†ï¼ˆä¼˜å…ˆçº§1ï¼‰###
${knowledge || 'ï¼ˆæš‚æ— ï¼‰'}

### ä»Šæ—¥å¯¹è¯è®°å½•ï¼ˆä¼˜å…ˆçº§2ï¼‰###
**è¿™æ˜¯ä»Šå¤©çš„å¯¹è¯ä¸Šä¸‹æ–‡ï¼Œå›ç­”æ—¶è¯·å‚è€ƒï¼**
${dialogueLines.length > 0 ? dialogueLines.join('\n') : 'ä»Šå¤©æš‚æ— å¯¹è¯è®°å½•'}

### çŸ­æœŸè®°å¿†ï¼ˆä¼˜å…ˆçº§3ï¼‰###
${shortMemory || 'æš‚æ— çŸ­æœŸè®°å¿†'}

### é•¿æœŸè®°å¿†ï¼ˆä¼˜å…ˆçº§4ï¼‰###
${longMemory || 'æš‚æ— é•¿æœŸè®°å¿†'}

### å›ç­”ä¼˜å…ˆçº§è¯´æ˜ ###
1. å¦‚æœæ˜¯å›ºå®šé—®ç­”ï¼ˆåœºæ™¯Aï¼‰ï¼Œä¸¥æ ¼æŒ‰é¢„è®¾å›ç­”ï¼Œä¸€å­—ä¸æ”¹
2. å¦‚æœèƒ½ä»èƒŒæ™¯çŸ¥è¯†ä¸­æ‰¾åˆ°ç­”æ¡ˆï¼Œä¼˜å…ˆä½¿ç”¨
3. å¦‚æœé—®åˆ°"åˆšæ‰è¯´äº†ä»€ä¹ˆ"ç­‰ï¼Œå‚è€ƒä»Šæ—¥å¯¹è¯è®°å½•
4. ç»“åˆçŸ­æœŸè®°å¿†å’Œé•¿æœŸè®°å¿†è¡¥å……å›ç­”`;

            return prompt;
        }
        
        // ==================== å¯¹è¯æ˜¾ç¤º ====================
        
        function addTranscript(role, text) {
            const line = document.createElement('div');
            line.className = role;
            const prefix = role === 'user' ? 'ğŸ§‘ ' : (role === 'ai' ? 'ğŸ¤– ' : '');
            line.textContent = prefix + text;
            transcriptContentEl.appendChild(line);
            transcriptContentEl.scrollTop = transcriptContentEl.scrollHeight;
            while (transcriptContentEl.children.length > 15) {
                transcriptContentEl.removeChild(transcriptContentEl.firstChild);
            }
        }
        
        // ==================== ä¼šè¯æ§åˆ¶ ====================
        
        async function toggleSession() {
            if (isSessionActive) {
                stopSession();
            } else {
                await startSession();
            }
        }
        
        async function startSession() {
            if (!apiKey) { alert('è¯·å…ˆè¾“å…¥ API Key'); return; }
            
            try {
                if (!audioCtx) {
                    audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 });
                    analyser = audioCtx.createAnalyser();
                } else if (audioCtx.state === 'suspended') {
                    await audioCtx.resume();
                }
                
                micStream = await navigator.mediaDevices.getUserMedia({ 
                    audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true } 
                });
                
                micSource = audioCtx.createMediaStreamSource(micStream);
                micProcessor = audioCtx.createScriptProcessor(4096, 1, 1);
                micSource.connect(micProcessor);
                micProcessor.connect(audioCtx.destination);
                
                // åŠ è½½çŸ¥è¯†åº“
                if (knowledgeFolderHandle) {
                    await loadKnowledgeBase();
                }
                
                const omniModel = 'qwen3-omni-flash-realtime-2025-12-01';
                const wsUrl = `wss://dashscope.aliyuncs.com/api-ws/v1/realtime?model=${omniModel}&api_key=${apiKey}`;
                
                statusEl.textContent = 'æ­£åœ¨è¿æ¥...';
                ws = new WebSocket(wsUrl);
                ws.binaryType = 'arraybuffer';
                
                ws.onopen = async () => {
                    console.log('WebSocket connected');
                    
                    const systemPrompt = await generateSystemPrompt();
                    
                    const sessionUpdate = {
                        type: 'session.update',
                        session: {
                            modalities: ['audio', 'text'],  // video ä¸è¢«æ”¯æŒ
                            voice: 'Serena',
                            instructions: systemPrompt,
                            input_audio_format: 'pcm16',
                            output_audio_format: 'pcm16',
                            turn_detection: { type: 'server_vad' },
                            input_audio_transcription: { model: 'qwen3-asr-flash-realtime' }
                        }
                    };
                    ws.send(JSON.stringify(sessionUpdate));
                    
                    isSessionActive = true;
                    toggleBtn.textContent = 'â¹ï¸ åœæ­¢ç›‘å¬';
                    toggleBtn.classList.add('active');
                    statusEl.textContent = 'ğŸ‘‚ æŒç»­ç›‘å¬ä¸­...';
                    statusEl.className = 'status-text listening';
                    
                    transcriptContentEl.innerHTML = '<div class="system">å¼€å§‹ç›‘å¬ï¼Œç­‰å¾…å”¤é†’è¯...</div>';
                    updateSessionIndicator();
                    
                    // å¯åŠ¨å®šæ—¶æ€»ç»“
                    startSummaryTimer();
                    
                    // å¯åŠ¨ä¸Šä¸‹æ–‡åˆ·æ–°ï¼ˆæ¯15ç§’ï¼‰
                    startContextRefreshTimer();
                    
                    setAvatarState('idle');
                    
                    micProcessor.onaudioprocess = (e) => {
                        if (ws && ws.readyState === WebSocket.OPEN) {
                            const inputData = e.inputBuffer.getChannelData(0);
                            const ratio = audioCtx.sampleRate / 16000;
                            const newLength = Math.floor(inputData.length / ratio);
                            const int16Data = new Int16Array(newLength);
                            
                            for (let i = 0; i < newLength; i++) {
                                const s = Math.max(-1, Math.min(1, inputData[Math.floor(i * ratio)]));
                                int16Data[i] = s < 0 ? s * 0x8000 : s * 0x7FFF;
                            }
                            
                            const audioEvent = {
                                type: 'input_audio_buffer.append',
                                audio: arrayBufferToBase64(int16Data.buffer)
                            };
                            ws.send(JSON.stringify(audioEvent));
                            hasAudioSent = true;  // æ ‡è®°å·²å‘é€è¿‡éŸ³é¢‘
                        }
                    };
                };
                
                ws.onmessage = async (event) => {
                    if (typeof event.data === 'string') {
                        try {
                            const msg = JSON.parse(event.data);
                            await handleServerMessage(msg);
                        } catch (e) { console.log('Parse error:', e); }
                    } else {
                        // åªæœ‰é—¨å¼€ç€æ‰æ’­æ”¾éŸ³é¢‘
                        if (isGateOpen) {
                            playAudioChunk(event.data);
                        }
                    }
                };
                
                ws.onerror = (error) => {
                    console.error('WebSocket error:', error);
                    statusEl.textContent = 'âŒ è¿æ¥é”™è¯¯';
                    statusEl.className = 'status-text error';
                };
                
                ws.onclose = () => {
                    console.log('WebSocket closed');
                    if (isSessionActive) stopSession();
                };
                
            } catch (err) {
                console.error('Start error:', err);
                statusEl.textContent = 'âŒ ' + err.message;
                statusEl.className = 'status-text error';
            }
        }
        
        async function handleServerMessage(msg) {
            const msgType = msg.type || '';
            
            // ç”¨æˆ·å¼€å§‹è¯´è¯ - æ‰“æ–­
            if (msgType === 'input_audio_buffer.speech_started') {
                clearAudioQueue();
                audioBuffer = [];
                isGateOpen = false;
            }
            
            // ç”¨æˆ·è¯­éŸ³è½¬å†™å®Œæˆ
            else if (msgType === 'conversation.item.input_audio_transcription.completed') {
                const transcript = (msg.transcript || '').trim();
                if (!transcript) return;
                
                // ã€é‡è¦ã€‘æ‰€æœ‰ç›‘å¬å†…å®¹éƒ½è®°å½•åˆ° dialogue.txtï¼Œä¸ç®¡æ˜¯å¦å“åº”
                // æ ¼å¼ä¸ Python ä¸€è‡´: [YYYY-MM-DD HH:MM:SS] å†…å®¹
                const timestamp = formatTimestamp(new Date());
                await appendFile('dialogue.txt', `[${timestamp}] ${transcript}\n`);
                
                // åˆ¤æ–­æ˜¯å¦åº”è¯¥å“åº”
                const decision = shouldRespond(transcript);
                
                if (decision.respond) {
                    addTranscript('user', transcript);
                    isGateOpen = true;
                    
                    if (decision.goodbye) {
                        addTranscript('system', 'ğŸ‘‹ å†è§ï¼');
                        setTimeout(() => deactivateSession(), 1000);
                    } else if (decision.command) {
                        await handleCommand(decision.command);
                    } else if (decision.active && !decision.wake) {
                        consumeTurn();
                    }
                    
                    // æ’­æ”¾ç¼“å†²çš„éŸ³é¢‘
                    audioBuffer.forEach(chunk => playAudioChunk(chunk));
                    audioBuffer = [];
                    
                    console.log('ğŸ”´ å“åº”:', transcript);
                } else {
                    // é™é»˜ç›‘å¬ï¼ˆä¹Ÿå·²è®°å½•åˆ°dialogue.txtï¼‰
                    console.log('âšª ç›‘å¬:', transcript);
                    addTranscript('system', `[ç›‘å¬] ${transcript}`);
                    audioBuffer = [];
                }
            }
            
            // AIå›å¤æ–‡æœ¬
            else if (msgType === 'response.audio_transcript.done') {
                const transcript = (msg.transcript || '').trim();
                if (transcript && isGateOpen) {
                    addTranscript('ai', transcript);
                    // æ ¼å¼ä¸ Python ä¸€è‡´: [YYYY-MM-DD HH:MM:SS] å†…å®¹
                    const timestamp = formatTimestamp(new Date());
                    await appendFile('dialogue.txt', `[${timestamp}] ${transcript}\n`);
                }
            }
            
            // éŸ³é¢‘æ•°æ®
            else if (msgType === 'response.audio.delta') {
                if (msg.delta) {
                    const audioBytes = base64ToArrayBuffer(msg.delta);
                    if (isGateOpen) {
                        playAudioChunk(audioBytes);
                    } else {
                        audioBuffer.push(audioBytes);
                    }
                }
            }
            
            // é”™è¯¯
            else if (msgType === 'error') {
                console.error('Server error:', msg);
            }
        }
        
        function stopSession() {
            isSessionActive = false;
            deactivateSession();
            stopSummaryTimer();
            stopContextRefreshTimer();
            stopCamera();
            stopScreenShare();
            clearAudioQueue();
            setAvatarState('idle');
            
            if (ws) { ws.onclose = null; ws.close(); ws = null; }
            if (micProcessor) { micProcessor.onaudioprocess = null; micProcessor.disconnect(); micProcessor = null; }
            if (micSource) { micSource.disconnect(); micSource = null; }
            if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
            
            toggleBtn.textContent = 'ğŸ¤ å¼€å§‹ç›‘å¬';
            toggleBtn.classList.remove('active');
            statusEl.textContent = 'å·²åœæ­¢';
            statusEl.className = 'status-text';
            sessionIndicatorEl.textContent = '';
        }
        
        // ==================== éŸ³é¢‘æ’­æ”¾ ====================
        
        function clearAudioQueue() {
            activeAudioSources.forEach(s => { try { s.stop(); } catch {} });
            activeAudioSources = [];
            if (audioCtx) nextPlayTime = audioCtx.currentTime;
            setAvatarState('idle');
        }
        
        function playAudioChunk(arrayBuffer) {
            if (!audioCtx || !arrayBuffer || arrayBuffer.byteLength === 0) return;
            
            try {
                const int16 = new Int16Array(arrayBuffer);
                const float32 = new Float32Array(int16.length);
                for (let i = 0; i < int16.length; i++) float32[i] = int16[i] / 32768.0;
                
                const buffer = audioCtx.createBuffer(1, float32.length, 24000);
                buffer.getChannelData(0).set(float32);
                
                const source = audioCtx.createBufferSource();
                source.buffer = buffer;
                source.connect(analyser);
                analyser.connect(audioCtx.destination);
                
                if (nextPlayTime < audioCtx.currentTime) nextPlayTime = audioCtx.currentTime;
                source.start(nextPlayTime);
                nextPlayTime += buffer.duration;
                
                setAvatarState('talking');
                activeAudioSources.push(source);
                
                source.onended = () => {
                    activeAudioSources = activeAudioSources.filter(s => s !== source);
                    if (activeAudioSources.length === 0) setAvatarState('idle');
                };
            } catch (e) { console.error('Play error:', e); }
        }
        
        // ==================== å·¥å…·å‡½æ•° ====================
        
        function arrayBufferToBase64(buffer) {
            const bytes = new Uint8Array(buffer);
            let binary = '';
            for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);
            return btoa(binary);
        }
        
        function base64ToArrayBuffer(base64) {
            const binary = atob(base64);
            const bytes = new Uint8Array(binary.length);
            for (let i = 0; i < binary.length; i++) bytes[i] = binary.charCodeAt(i);
            return bytes.buffer;
        }
        
        // æ ¼å¼åŒ–æ—¶é—´æˆ³ï¼Œä¸ Python æ ¼å¼ä¸€è‡´: YYYY-MM-DD HH:MM:SS
        function formatTimestamp(date) {
            const pad = n => n.toString().padStart(2, '0');
            return `${date.getFullYear()}-${pad(date.getMonth()+1)}-${pad(date.getDate())} ${pad(date.getHours())}:${pad(date.getMinutes())}:${pad(date.getSeconds())}`;
        }
    </script>
</body>
</html>
