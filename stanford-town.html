<!DOCTYPE html>
<html lang="zh-CN">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Stanford Small Town - AI å°é•‡æ¨¡æ‹Ÿ</title>
<style>
  *, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }
  :root {
    --bg: #0f1923; --panel: #1a2733; --panel2: #243442;
    --accent: #4fc3f7; --accent2: #81d4fa; --warm: #ffb74d;
    --green: #66bb6a; --red: #ef5350; --purple: #ab47bc;
    --text: #e0e0e0; --text2: #90a4ae; --border: #37474f;
  }
  body {
    font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
    background: var(--bg); color: var(--text);
    min-height: 100vh; overflow: hidden;
  }
  /* Layout */
  .app { display: grid; grid-template-columns: 280px 1fr 320px; grid-template-rows: 56px 1fr 200px; height: 100vh; }
  .header { grid-column: 1/-1; background: var(--panel); border-bottom: 1px solid var(--border); display: flex; align-items: center; padding: 0 20px; gap: 16px; }
  .header h1 { font-size: 18px; font-weight: 600; color: var(--accent); }
  .header .time-display { margin-left: auto; font-size: 14px; color: var(--warm); font-variant-numeric: tabular-nums; }
  .header .controls { display: flex; gap: 8px; }
  .header button { background: var(--panel2); border: 1px solid var(--border); color: var(--text); padding: 6px 14px; border-radius: 6px; cursor: pointer; font-size: 13px; transition: all .15s; }
  .header button:hover { background: var(--accent); color: var(--bg); }
  .header button.active { background: var(--accent); color: var(--bg); }
  .header button.danger { border-color: var(--red); }
  .header button.danger:hover { background: var(--red); }
  /* Sidebar */
  .sidebar { background: var(--panel); border-right: 1px solid var(--border); overflow-y: auto; padding: 12px; }
  .sidebar h3 { font-size: 12px; text-transform: uppercase; color: var(--text2); letter-spacing: 1px; margin-bottom: 8px; }
  .agent-card { background: var(--panel2); border: 1px solid var(--border); border-radius: 8px; padding: 10px; margin-bottom: 8px; cursor: pointer; transition: all .15s; }
  .agent-card:hover { border-color: var(--accent); }
  .agent-card.selected { border-color: var(--accent); box-shadow: 0 0 0 1px var(--accent); }
  .agent-card .name { font-size: 14px; font-weight: 600; display: flex; align-items: center; gap: 6px; }
  .agent-card .emoji { font-size: 20px; }
  .agent-card .status { font-size: 11px; color: var(--text2); margin-top: 4px; }
  .agent-card .mood { font-size: 11px; margin-top: 2px; }
  .agent-card .location { font-size: 11px; color: var(--green); margin-top: 2px; }
  /* Map */
  .map-container { position: relative; overflow: hidden; background: #0d1520; }
  .map-canvas { width: 100%; height: 100%; }
  /* Right panel */
  .right-panel { background: var(--panel); border-left: 1px solid var(--border); overflow-y: auto; padding: 12px; display: flex; flex-direction: column; gap: 12px; }
  .right-panel h3 { font-size: 12px; text-transform: uppercase; color: var(--text2); letter-spacing: 1px; }
  .memory-section { background: var(--panel2); border-radius: 8px; padding: 10px; }
  .memory-section h4 { font-size: 13px; color: var(--accent); margin-bottom: 6px; }
  .memory-item { font-size: 12px; color: var(--text2); padding: 4px 0; border-bottom: 1px solid var(--border); line-height: 1.4; }
  .memory-item:last-child { border-bottom: none; }
  .memory-item .time { color: var(--warm); font-size: 11px; }
  .thought-bubble { background: var(--panel2); border-radius: 8px; padding: 10px; border-left: 3px solid var(--purple); }
  .thought-bubble .label { font-size: 11px; color: var(--purple); margin-bottom: 4px; }
  .thought-bubble .content { font-size: 12px; line-height: 1.5; }
  /* Log */
  .log-panel { grid-column: 1/-1; background: var(--panel); border-top: 1px solid var(--border); overflow-y: auto; padding: 12px; }
  .log-panel h3 { font-size: 12px; text-transform: uppercase; color: var(--text2); letter-spacing: 1px; margin-bottom: 8px; position: sticky; top: 0; background: var(--panel); }
  .log-entry { font-size: 12px; padding: 3px 0; line-height: 1.5; display: flex; gap: 8px; }
  .log-entry .log-time { color: var(--warm); min-width: 50px; font-variant-numeric: tabular-nums; }
  .log-entry .log-agent { color: var(--accent); min-width: 60px; font-weight: 600; }
  .log-entry .log-text { color: var(--text2); }
  .log-entry.event .log-text { color: var(--green); }
  .log-entry.thought .log-text { color: var(--purple); font-style: italic; }
  .log-entry.conversation .log-text { color: var(--accent2); }
  /* API key modal */
  .modal-overlay { position: fixed; inset: 0; background: rgba(0,0,0,.7); display: flex; align-items: center; justify-content: center; z-index: 100; }
  .modal { background: var(--panel); border: 1px solid var(--border); border-radius: 12px; padding: 24px; width: 440px; }
  .modal h2 { font-size: 18px; margin-bottom: 12px; color: var(--accent); }
  .modal p { font-size: 13px; color: var(--text2); margin-bottom: 16px; line-height: 1.5; }
  .modal input { width: 100%; padding: 10px 12px; background: var(--panel2); border: 1px solid var(--border); border-radius: 6px; color: var(--text); font-size: 14px; outline: none; }
  .modal input:focus { border-color: var(--accent); }
  .modal .btn-row { display: flex; gap: 8px; margin-top: 16px; justify-content: flex-end; }
  .modal button { padding: 8px 20px; border-radius: 6px; border: 1px solid var(--border); cursor: pointer; font-size: 13px; }
  .modal .btn-primary { background: var(--accent); color: var(--bg); border-color: var(--accent); }
  .speed-control { display: flex; align-items: center; gap: 6px; font-size: 12px; color: var(--text2); }
  .speed-control select { background: var(--panel2); border: 1px solid var(--border); color: var(--text); padding: 4px 8px; border-radius: 4px; font-size: 12px; }
  .hidden { display: none !important; }
  ::-webkit-scrollbar { width: 6px; }
  ::-webkit-scrollbar-track { background: transparent; }
  ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
</style>
</head>
<body>
<div class="app">
  <div class="header">
    <h1>ğŸ˜ï¸ Stanford Small Town</h1>
    <div class="speed-control">
      <span>é€Ÿåº¦:</span>
      <select id="speedSelect">
        <option value="1">1x</option>
        <option value="2">2x</option>
        <option value="5" selected>5x</option>
        <option value="10">10x</option>
        <option value="30">30x</option>
      </select>
    </div>
    <div class="time-display" id="timeDisplay">Day 1 Â· 06:00</div>
    <div class="controls">
      <button id="btnPlay" class="active">â–¶ è¿è¡Œ</button>
      <button id="btnPause">â¸ æš‚åœ</button>
      <button id="btnReset" class="danger">â†º é‡ç½®</button>
    </div>
  </div>
  <div class="sidebar" id="sidebar"></div>
  <div class="map-container">
    <canvas class="map-canvas" id="mapCanvas"></canvas>
  </div>
  <div class="right-panel" id="rightPanel">
    <h3>ğŸ§  é€‰ä¸­å±…æ°‘è¯¦æƒ…</h3>
    <div id="agentDetail" style="font-size:13px;color:var(--text2);">ç‚¹å‡»å·¦ä¾§å±…æ°‘æŸ¥çœ‹è¯¦æƒ…</div>
  </div>
  <div class="log-panel" id="logPanel">
    <h3>ğŸ“œ å°é•‡æ—¥å¿—</h3>
  </div>
</div>

<div class="modal-overlay" id="apiModal">
  <div class="modal">
    <h2>ğŸ”‘ é…ç½® Qwen API</h2>
    <p>æœ¬æ¸¸æˆä½¿ç”¨ DashScopeï¼ˆé˜¿é‡Œäº‘ç™¾ç‚¼ï¼‰API é©±åŠ¨å±…æ°‘çš„æ€è€ƒã€è®°å¿†å’Œå¯¹è¯ã€‚<br>
    æ¨¡å‹ï¼šqwen3-max Â· æ¥å£ï¼šOpenAI å…¼å®¹æ¨¡å¼</p>
    <input type="password" id="apiKeyInput" placeholder="sk-xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx" />
    <div class="btn-row">
      <button onclick="startWithDemo()">ğŸ® æ¼”ç¤ºæ¨¡å¼ï¼ˆæ— éœ€ APIï¼‰</button>
      <button class="btn-primary" onclick="startWithApi()">ç¡®è®¤</button>
    </div>
  </div>
</div>

<script>
// ============================================================
// Stanford Small Town - Generative Agents Simulation
// Memory architecture inspired by OpenClaw:
// - Daily logs (memory/YYYY-MM-DD.md pattern)
// - Long-term curated memory (MEMORY.md pattern)
// - Reflection & compaction (pre-compaction memory flush)
// - Vector-like importance scoring for memory retrieval
// ============================================================

const CONFIG = {
  apiKey: '',
  baseUrl: 'https://dashscope.aliyuncs.com/compatible-mode/v1',
  model: 'qwen3-max',
  demoMode: false,
};

// ---- Town Map ----
const LOCATIONS = [
  { id: 'home_lin',    name: 'æ—å®¶', x: 80, y: 100, w: 60, h: 50, color: '#5c6bc0', type: 'home' },
  { id: 'home_chen',   name: 'é™ˆå®¶', x: 80, y: 220, w: 60, h: 50, color: '#7e57c2', type: 'home' },
  { id: 'home_wang',   name: 'ç‹å®¶', x: 80, y: 340, w: 60, h: 50, color: '#26a69a', type: 'home' },
  { id: 'cafe',        name: 'å’–å•¡é¦†', x: 260, y: 80, w: 80, h: 60, color: '#8d6e63', type: 'commercial' },
  { id: 'library',     name: 'å›¾ä¹¦é¦†', x: 260, y: 200, w: 80, h: 60, color: '#42a5f5', type: 'commercial' },
  { id: 'park',        name: 'å…¬å›­', x: 260, y: 340, w: 100, h: 70, color: '#66bb6a', type: 'nature' },
  { id: 'store',       name: 'æ‚è´§åº—', x: 440, y: 80, w: 70, h: 60, color: '#ffa726', type: 'commercial' },
  { id: 'school',      name: 'å­¦æ ¡', x: 440, y: 200, w: 80, h: 60, color: '#ef5350', type: 'commercial' },
  { id: 'restaurant',  name: 'é¤é¦†', x: 440, y: 340, w: 70, h: 60, color: '#ec407a', type: 'commercial' },
  { id: 'town_square', name: 'å°é•‡å¹¿åœº', x: 260, y: 460, w: 120, h: 50, color: '#78909c', type: 'public' },
];

// ---- Agents (Residents) ----
const AGENT_TEMPLATES = [
  {
    id: 'lin_mei', name: 'æ—æ¢…', emoji: 'ğŸ‘©â€ğŸ«', age: 34,
    occupation: 'å°å­¦æ•™å¸ˆ',
    personality: 'æ¸©æŸ”ç»†å¿ƒï¼Œçƒ­çˆ±æ•™è‚²ï¼Œå–œæ¬¢è¯»ä¹¦å’Œå›­è‰º',
    home: 'home_lin',
    routine: { wake: 6, sleep: 22 },
    relationships: { chen_wei: 'é‚»å±…å’Œå¥½å‹', wang_gang: 'å­¦ç”Ÿå®¶é•¿' },
    initialMemory: ['ä»Šå¤©æ˜¯æ¥åˆ°å°é•‡çš„ç¬¬ä¸€å¤©ï¼Œæ„Ÿè§‰ä¸€åˆ‡éƒ½å¾ˆæ–°é²œã€‚', 'æˆ‘å–œæ¬¢åœ¨æ—©æ™¨å»å’–å•¡é¦†å–ä¸€æ¯æ‹¿é“å†å»å­¦æ ¡ã€‚']
  },
  {
    id: 'chen_wei', name: 'é™ˆä¼Ÿ', emoji: 'ğŸ‘¨â€ğŸ³', age: 42,
    occupation: 'é¤é¦†è€æ¿',
    personality: 'çƒ­æƒ…è±ªçˆ½ï¼Œå¨è‰ºç²¾æ¹›ï¼Œçˆ±å¼€ç©ç¬‘ï¼Œæœ‰æ—¶è¿‡äºç›´ç‡',
    home: 'home_chen',
    routine: { wake: 5, sleep: 23 },
    relationships: { lin_mei: 'é‚»å±…å’Œå¥½å‹', wang_gang: 'å¸¸å®¢' },
    initialMemory: ['æˆ‘çš„é¤é¦†"é™ˆè®°å°å¨"å¼€ä¸šä¸‰å¹´äº†ï¼Œç”Ÿæ„è¿˜ä¸é”™ã€‚', 'æ¯å¤©æ—©ä¸Šäº”ç‚¹èµ·æ¥å‡†å¤‡é£Ÿææ˜¯æˆ‘çš„ä¹ æƒ¯ã€‚']
  },
  {
    id: 'wang_gang', name: 'ç‹åˆš', emoji: 'ğŸ‘¨â€ğŸ’»', age: 28,
    occupation: 'è‡ªç”±ç¨‹åºå‘˜',
    personality: 'å†…å‘å®‰é™ï¼ŒæŠ€æœ¯å®…ï¼Œæ™šç¡æ™šèµ·ï¼Œå–œæ¬¢çŒ«',
    home: 'home_wang',
    routine: { wake: 9, sleep: 1 },
    relationships: { lin_mei: 'å°æ—¶å€™çš„è€å¸ˆ', chen_wei: 'æœ€å–œæ¬¢å»ä»–é¤é¦†åƒé¥­' },
    initialMemory: ['è¿œç¨‹å·¥ä½œè®©æˆ‘å¯ä»¥ä½åœ¨è¿™ä¸ªå®‰é™çš„å°é•‡ã€‚', 'æˆ‘å…»äº†ä¸€åªå«"æ¯”ç‰¹"çš„æ©˜çŒ«ã€‚', 'æœ€è¿‘åœ¨åšä¸€ä¸ªç‹¬ç«‹æ¸¸æˆé¡¹ç›®ã€‚']
  },
  {
    id: 'zhao_li', name: 'èµµä¸½', emoji: 'ğŸ‘©â€âš•ï¸', age: 38,
    occupation: 'å°é•‡è¯Šæ‰€åŒ»ç”Ÿ',
    personality: 'å†·é™ç†æ€§ï¼Œæœ‰åŒæƒ…å¿ƒï¼Œå·¥ä½œè®¤çœŸï¼Œå¶å°”ä¸¥è‚ƒè¿‡å¤´',
    home: 'home_lin',
    routine: { wake: 6, sleep: 22 },
    relationships: { lin_mei: 'å®¤å‹', chen_wei: 'ç»å¸¸æé†’ä»–æ³¨æ„å¥åº·' },
    initialMemory: ['å°é•‡è™½å°ä½†éœ€è¦ä¸€ä¸ªåŒ»ç”Ÿã€‚', 'å’Œæ—æ¢…åˆç§Ÿçœé’±åˆæœ‰ä¸ªä¼´ã€‚']
  },
  {
    id: 'liu_peng', name: 'åˆ˜é¹', emoji: 'ğŸ‘´', age: 67,
    occupation: 'é€€ä¼‘æ•™æˆ',
    personality: 'åšå­¦å¤šé—»ï¼Œå–œæ¬¢ä¸‹æ£‹ï¼Œå¶å°”å•°å—¦ï¼Œå¿ƒåœ°å–„è‰¯',
    home: 'home_chen',
    routine: { wake: 5, sleep: 21 },
    relationships: { chen_wei: 'å„¿å­', wang_gang: 'å¿˜å¹´äº¤ï¼Œç»å¸¸ä¸€èµ·ä¸‹æ£‹' },
    initialMemory: ['é€€ä¼‘åæ¬æ¥å’Œå„¿å­ä½ï¼Œäº«å—å°é•‡çš„å®é™ã€‚', 'æ¯å¤©åœ¨å…¬å›­ä¸‹æ£‹æ˜¯æœ€å¿«ä¹çš„æ—¶å…‰ã€‚']
  },
];

// ---- Memory System (inspired by OpenClaw) ----
class MemoryManager {
  constructor(agentId) {
    this.agentId = agentId;
    // Short-term: observations stream (like session transcript)
    this.stream = [];
    // Daily log: memory/YYYY-MM-DD.md pattern
    this.dailyLogs = {};
    // Long-term curated: MEMORY.md pattern
    this.longTerm = [];
    // Reflection summaries (compaction output)
    this.reflections = [];
    // Importance scores for retrieval ranking
    this.importanceScores = new Map();
  }

  addObservation(text, time, importance = 5) {
    const entry = { text, time: formatTime(time), timestamp: time.total, importance, type: 'observation' };
    this.stream.push(entry);
    this.importanceScores.set(text, importance);
    const dayKey = `Day${time.day}`;
    if (!this.dailyLogs[dayKey]) this.dailyLogs[dayKey] = [];
    this.dailyLogs[dayKey].push(entry);
  }

  addReflection(text, time, sources = []) {
    const entry = { text, time: formatTime(time), timestamp: time.total, type: 'reflection', sources };
    this.reflections.push(entry);
    this.longTerm.push(entry);
    this.importanceScores.set(text, 8);
  }

  // Retrieve memories ranked by recency + importance + relevance
  retrieve(query, limit = 5) {
    const all = [...this.stream, ...this.reflections];
    const scored = all.map(m => {
      const recency = 1 / (1 + (simState.time.total - m.timestamp) / 60);
      const importance = (this.importanceScores.get(m.text) || 5) / 10;
      const relevance = textSimilarity(query, m.text);
      return { ...m, score: recency * 0.3 + importance * 0.3 + relevance * 0.4 };
    });
    scored.sort((a, b) => b.score - a.score);
    return scored.slice(0, limit);
  }

  getRecentStream(n = 8) {
    return this.stream.slice(-n);
  }

  getDailyLog(day) {
    return this.dailyLogs[`Day${day}`] || [];
  }

  getLongTermSummary() {
    return this.longTerm.slice(-5).map(m => m.text);
  }

  // Pre-compaction flush: save important memories before context is lost
  needsCompaction() {
    return this.stream.length > 20;
  }

  compact(reflectionText, time) {
    this.addReflection(reflectionText, time, this.stream.slice(-20).map(m => m.text));
    this.stream = this.stream.slice(-5);
  }
}

// Simple text similarity (keyword overlap)
function textSimilarity(a, b) {
  const tokA = new Set(a.split(/\s+/));
  const tokB = new Set(b.split(/\s+/));
  let overlap = 0;
  for (const t of tokA) if (tokB.has(t)) overlap++;
  return overlap / Math.max(tokA.size, tokB.size, 1);
}

// ---- Agent class ----
class Agent {
  constructor(template) {
    Object.assign(this, template);
    this.memory = new MemoryManager(this.id);
    this.currentLocation = this.home;
    this.targetLocation = null;
    this.currentAction = 'ç¡è§‰';
    this.currentThought = '';
    this.mood = 'å¹³é™';
    this.moveProgress = 0;
    this.x = 0; this.y = 0;
    this.actionTimer = 0;
    this.lastReflectionTime = 0;
    this.conversationPartner = null;
    this.conversationCooldown = 0;
    // Initialize position
    const loc = LOCATIONS.find(l => l.id === this.home);
    if (loc) { this.x = loc.x + loc.w/2; this.y = loc.y + loc.h/2; }
    // Seed initial memories
    template.initialMemory.forEach(m => {
      this.memory.addObservation(m, { day: 1, hour: 0, minute: 0, total: 0 }, 7);
    });
  }
}

// ---- Simulation State ----
const simState = {
  time: { day: 1, hour: 6, minute: 0, total: 360 },
  agents: [],
  running: false,
  speed: 5,
  selectedAgent: null,
  logs: [],
  pendingApiCalls: 0,
};

// ---- Time Helpers ----
function formatTime(t) {
  return `Day ${t.day} Â· ${String(t.hour).padStart(2,'0')}:${String(t.minute).padStart(2,'0')}`;
}

function advanceTime(minutes) {
  simState.time.minute += minutes;
  simState.time.total += minutes;
  while (simState.time.minute >= 60) {
    simState.time.minute -= 60;
    simState.time.hour++;
  }
  while (simState.time.hour >= 24) {
    simState.time.hour -= 24;
    simState.time.day++;
  }
}

// ---- Qwen API ----
async function callQwen(systemPrompt, userPrompt, maxTokens = 300) {
  if (CONFIG.demoMode) return demoResponse(userPrompt);
  simState.pendingApiCalls++;
  try {
    const res = await fetch(`${CONFIG.baseUrl}/chat/completions`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${CONFIG.apiKey}` },
      body: JSON.stringify({
        model: CONFIG.model,
        messages: [
          { role: 'system', content: systemPrompt },
          { role: 'user', content: userPrompt },
        ],
        max_tokens: maxTokens,
        temperature: 0.8,
        extra_body: { enable_thinking: false },
      }),
    });
    const data = await res.json();
    if (data.error) { console.warn('API error:', data.error); return demoResponse(userPrompt); }
    return data.choices?.[0]?.message?.content?.trim() || demoResponse(userPrompt);
  } catch (e) {
    console.warn('API call failed:', e);
    return demoResponse(userPrompt);
  } finally {
    simState.pendingApiCalls--;
  }
}

// Demo mode responses
function demoResponse(prompt) {
  const actions = [
    'å»å’–å•¡é¦†å–æ¯å’–å•¡ï¼Œæ€è€ƒä¸€ä¸‹ä»Šå¤©çš„å®‰æ’',
    'åœ¨å…¬å›­æ•£æ­¥ï¼Œäº«å—æ—©æ™¨çš„é˜³å…‰',
    'å»å›¾ä¹¦é¦†çœ‹çœ‹æœ‰ä»€ä¹ˆæ–°ä¹¦',
    'åˆ°æ‚è´§åº—ä¹°äº›æ—¥ç”¨å“',
    'åœ¨å°é•‡å¹¿åœºååï¼Œçœ‹çœ‹è·¯è¿‡çš„äºº',
    'å›å®¶ä¼‘æ¯ä¸€ä¼šå„¿',
    'å»é¤é¦†åƒä¸ªä¾¿é¥­',
    'åœ¨å­¦æ ¡å‡†å¤‡æ˜å¤©çš„è¯¾ç¨‹',
  ];
  const thoughts = [
    'ä»Šå¤©å¤©æ°”çœŸä¸é”™ï¼Œé€‚åˆå‡ºå»èµ°èµ°ã€‚',
    'æœ€è¿‘è¿‡å¾—æŒºå……å®çš„ï¼Œå°é•‡ç”Ÿæ´»å¾ˆæƒ¬æ„ã€‚',
    'ä¸çŸ¥é“ä»Šå¤©ä¼šé‡åˆ°è°ï¼ŒæœŸå¾…æœ‰è¶£çš„å¯¹è¯ã€‚',
    'è¯¥æ•´ç†ä¸€ä¸‹æœ€è¿‘çš„æƒ³æ³•äº†ã€‚',
    'ç”Ÿæ´»åœ¨è¿™é‡Œè®©æˆ‘æ„Ÿåˆ°å¹³é™ã€‚',
  ];
  const moods = ['å¼€å¿ƒ', 'å¹³é™', 'å¥½å¥‡', 'æ»¡è¶³', 'æœ‰ç‚¹ç´¯', 'æœŸå¾…'];
  if (prompt.includes('è¡ŒåŠ¨è®¡åˆ’') || prompt.includes('æ¥ä¸‹æ¥')) {
    const a = actions[Math.floor(Math.random() * actions.length)];
    const locMap = { 'å’–å•¡é¦†': 'cafe', 'å…¬å›­': 'park', 'å›¾ä¹¦é¦†': 'library', 'æ‚è´§åº—': 'store', 'å¹¿åœº': 'town_square', 'é¤é¦†': 'restaurant', 'å­¦æ ¡': 'school' };
    // Prefer social hotspots so agents cluster together
    const hotspots = getSocialHotspots(simState.time.hour);
    let loc = hotspots[Math.floor(Math.random() * hotspots.length)];
    // 30% chance to go somewhere else for variety
    if (Math.random() < 0.3) {
      for (const [k, v] of Object.entries(locMap)) { if (a.includes(k)) { loc = v; break; } }
    }
    return JSON.stringify({ action: a, location: loc, thought: thoughts[Math.floor(Math.random() * thoughts.length)], mood: moods[Math.floor(Math.random() * moods.length)] });
  }
  if (prompt.includes('å¯¹è¯') || prompt.includes('äº¤è°ˆ')) {
    const lines = [
      'ä½ å¥½å•Šï¼ä»Šå¤©è¿‡å¾—æ€ä¹ˆæ ·ï¼Ÿ',
      'æœ€è¿‘åœ¨å¿™ä»€ä¹ˆå‘¢ï¼Ÿ',
      'å¤©æ°”è¿™ä¹ˆå¥½ï¼Œè¦ä¸è¦ä¸€èµ·å»å…¬å›­èµ°èµ°ï¼Ÿ',
      'å“ˆå“ˆï¼Œè¯´èµ·æ¥æˆ‘æœ€è¿‘å‘ç°äº†ä¸€å®¶ä¸é”™çš„ä¹¦ã€‚',
      'å¯¹äº†ï¼Œä½ å¬è¯´å°é•‡è¦åŠæ´»åŠ¨çš„äº‹äº†å—ï¼Ÿ',
    ];
    return lines[Math.floor(Math.random() * lines.length)];
  }
  if (prompt.includes('åæ€') || prompt.includes('æ€»ç»“')) {
    return 'ä»Šå¤©æ˜¯å¹³å‡¡è€Œå……å®çš„ä¸€å¤©ã€‚å’Œé‚»å±…èŠäº†å‡ å¥ï¼Œå»äº†å¸¸å»çš„åœ°æ–¹ã€‚å°é•‡çš„ç”Ÿæ´»è™½ç„¶ç®€å•ï¼Œä½†è®©äººæ„Ÿåˆ°å®‰å¿ƒã€‚';
  }
  return thoughts[Math.floor(Math.random() * thoughts.length)];
}

// ---- Agent AI Logic ----
function buildAgentSystemPrompt(agent) {
  const rels = Object.entries(agent.relationships).map(([id, desc]) => {
    const other = simState.agents.find(a => a.id === id);
    return other ? `- ${other.name}ï¼š${desc}` : '';
  }).filter(Boolean).join('\n');

  return `ä½ æ˜¯"${agent.name}"ï¼Œ${agent.age}å²ï¼Œ${agent.occupation}ã€‚
æ€§æ ¼ï¼š${agent.personality}
ä½ ä½åœ¨ Stanford Small Town å°é•‡ã€‚

## äººé™…å…³ç³»
${rels}

## è®°å¿†ç³»ç»Ÿ
ä½ æ‹¥æœ‰è®°å¿†èƒ½åŠ›ã€‚ä½ çš„å›å¿†å’Œç»å†ä¼šå½±å“ä½ çš„å†³ç­–ã€‚
é‡è¦çš„äº‹æƒ…ä½ ä¼šè®°ä½æ›´ä¹…ï¼Œæ—¥å¸¸çäº‹ä¼šé€æ¸æ·¡å¿˜ã€‚

## æŒ‡ä»¤
å§‹ç»ˆä»¥è§’è‰²èº«ä»½å›åº”ã€‚å›ç­”è¦ç®€çŸ­è‡ªç„¶ï¼ŒåƒçœŸäººä¸€æ ·ã€‚ç”¨ä¸­æ–‡å›ç­”ã€‚`;
}

// Social hotspots by time of day â€” encourages agents to visit same locations
function getSocialHotspots(hour) {
  if (hour >= 6 && hour < 9) return ['cafe', 'park'];          // morning: coffee & walks
  if (hour >= 9 && hour < 12) return ['library', 'school', 'store']; // morning: work
  if (hour >= 12 && hour < 14) return ['restaurant', 'cafe'];  // lunch
  if (hour >= 14 && hour < 17) return ['library', 'park', 'town_square']; // afternoon
  if (hour >= 17 && hour < 20) return ['park', 'town_square', 'restaurant']; // evening
  if (hour >= 20) return ['restaurant', 'cafe'];                // night
  return ['park'];
}

async function decideAction(agent) {
  const h = simState.time.hour;
  // Basic schedule constraints
  if (h >= agent.routine.sleep || h < agent.routine.wake) {
    agent.currentAction = 'ç¡è§‰';
    agent.targetLocation = agent.home;
    return;
  }

  const recentMemories = agent.memory.getRecentStream(5).map(m => `[${m.time}] ${m.text}`).join('\n');
  const longTermMemories = agent.memory.getLongTermSummary().join('\n');
  const nearbyAgents = simState.agents
    .filter(a => a.id !== agent.id && a.currentLocation === agent.currentLocation)
    .map(a => a.name);
  const hotspots = getSocialHotspots(h);
  const hotspotNames = hotspots.map(id => LOCATIONS.find(l => l.id === id)?.name).filter(Boolean);

  // Where are other agents now? Encourage social behavior
  const otherLocations = simState.agents
    .filter(a => a.id !== agent.id && a.currentAction !== 'ç¡è§‰')
    .map(a => { const loc = LOCATIONS.find(l => l.id === a.currentLocation); return loc ? `${a.name}åœ¨${loc.name}` : null; })
    .filter(Boolean);

  const prompt = `å½“å‰æ—¶é—´ï¼š${formatTime(simState.time)}
ä½ ç°åœ¨åœ¨ï¼š${LOCATIONS.find(l => l.id === agent.currentLocation)?.name || 'æœªçŸ¥'}
å½“å‰å¿ƒæƒ…ï¼š${agent.mood}
é™„è¿‘çš„äººï¼š${nearbyAgents.length > 0 ? nearbyAgents.join('ã€') : 'æ— '}
å…¶ä»–äººçš„ä½ç½®ï¼š${otherLocations.join('ã€') || 'ä¸æ¸…æ¥š'}
è¿™ä¸ªæ—¶æ®µçƒ­é—¹çš„åœ°æ–¹ï¼š${hotspotNames.join('ã€')}

## è¿‘æœŸè®°å¿†
${recentMemories || 'ï¼ˆæ— ï¼‰'}

## é•¿æœŸè®°å¿†
${longTermMemories || 'ï¼ˆæ— ï¼‰'}

## å¯å»çš„åœ°æ–¹
${LOCATIONS.map(l => `- ${l.name}(${l.id})`).join('\n')}

ä½ æ˜¯ä¸€ä¸ªç¤¾äº¤çš„äººï¼Œå–œæ¬¢å»æœ‰å…¶ä»–äººçš„åœ°æ–¹ã€‚è¯·å†³å®šä½ æ¥ä¸‹æ¥è¦åšä»€ä¹ˆã€‚ä»¥ JSON æ ¼å¼å›å¤ï¼š
{"action": "å…·ä½“è¡ŒåŠ¨æè¿°", "location": "åœ°ç‚¹id", "thought": "å†…å¿ƒæƒ³æ³•", "mood": "å½“å‰å¿ƒæƒ…"}`;

  const response = await callQwen(buildAgentSystemPrompt(agent), prompt, 200);
  try {
    const parsed = JSON.parse(response.replace(/```json\n?/g, '').replace(/```/g, '').trim());
    agent.currentAction = parsed.action || 'é—²é€›';
    agent.targetLocation = parsed.location || agent.currentLocation;
    agent.currentThought = parsed.thought || '';
    agent.mood = parsed.mood || agent.mood;
    agent.memory.addObservation(parsed.action, simState.time, 5);
    addLog(agent, parsed.action, 'event');
    if (parsed.thought) addLog(agent, parsed.thought, 'thought');
  } catch {
    agent.currentAction = 'é—²é€›';
    agent.targetLocation = ['cafe', 'park', 'library', 'town_square'][Math.floor(Math.random() * 4)];
  }
}

async function generateConversation(agent1, agent2) {
  if (agent1.conversationCooldown > 0 || agent2.conversationCooldown > 0) return;
  agent1.conversationCooldown = 8;
  agent2.conversationCooldown = 8;

  const memories1 = agent1.memory.retrieve(agent2.name, 3).map(m => m.text).join('; ');
  const memories2 = agent2.memory.retrieve(agent1.name, 3).map(m => m.text).join('; ');
  const locName = LOCATIONS.find(l => l.id === agent1.currentLocation)?.name || 'æŸå¤„';

  const prompt = `ä½ (${agent1.name})åœ¨${locName}é‡åˆ°äº†${agent2.name}ã€‚
ä½ å¯¹${agent2.name}çš„è®°å¿†ï¼š${memories1 || 'æ²¡æœ‰ç‰¹åˆ«çš„è®°å¿†'}
å½“å‰æ—¶é—´ï¼š${formatTime(simState.time)}
ä½ çš„å¿ƒæƒ…ï¼š${agent1.mood}

è¯·è¯´ä¸€å¥è‡ªç„¶çš„å¯¹è¯ï¼ˆ30å­—ä»¥å†…ï¼‰ï¼š`;

  const line1 = await callQwen(buildAgentSystemPrompt(agent1), prompt, 60);
  const cleanLine1 = line1.replace(/["""]/g, '').trim();

  const prompt2 = `${agent1.name}å¯¹ä½ è¯´ï¼š"${cleanLine1}"
ä½ å¯¹${agent1.name}çš„è®°å¿†ï¼š${memories2 || 'æ²¡æœ‰ç‰¹åˆ«çš„è®°å¿†'}
åœ°ç‚¹ï¼š${locName}
ä½ çš„å¿ƒæƒ…ï¼š${agent2.mood}

è¯·ç®€çŸ­å›åº”ï¼ˆ30å­—ä»¥å†…ï¼‰ï¼š`;

  const line2 = await callQwen(buildAgentSystemPrompt(agent2), prompt2, 60);
  const cleanLine2 = line2.replace(/["""]/g, '').trim();

  agent1.memory.addObservation(`å’Œ${agent2.name}èŠå¤©ï¼š"${cleanLine1}" â†’ "${cleanLine2}"`, simState.time, 6);
  agent2.memory.addObservation(`å’Œ${agent1.name}èŠå¤©ï¼š"${cleanLine1}" â†’ "${cleanLine2}"`, simState.time, 6);

  addLog(agent1, `å¯¹${agent2.name}è¯´ï¼š${cleanLine1}`, 'conversation');
  addLog(agent2, `å›å¤${agent1.name}ï¼š${cleanLine2}`, 'conversation');
}

async function reflect(agent) {
  if (simState.time.total - agent.lastReflectionTime < 120) return;
  if (!agent.memory.needsCompaction()) return;

  agent.lastReflectionTime = simState.time.total;
  const recentObs = agent.memory.getRecentStream(15).map(m => m.text).join('\n- ');

  const prompt = `åŸºäºä½ æœ€è¿‘çš„ç»å†ï¼Œè¿›è¡Œç®€çŸ­çš„åæ€æ€»ç»“ï¼ˆ50å­—ä»¥å†…ï¼‰ï¼š
- ${recentObs}

ä½ çš„åæ€ï¼š`;

  const reflection = await callQwen(buildAgentSystemPrompt(agent), prompt, 100);
  const clean = reflection.replace(/["""]/g, '').trim();
  agent.memory.compact(clean, simState.time);
  addLog(agent, `[åæ€] ${clean}`, 'thought');
}

// ---- Movement ----
function moveAgent(agent) {
  if (!agent.targetLocation || agent.targetLocation === agent.currentLocation) {
    agent.moveProgress = 0;
    return;
  }
  const target = LOCATIONS.find(l => l.id === agent.targetLocation);
  if (!target) return;
  const tx = target.x + target.w/2;
  const ty = target.y + target.h/2;
  const dx = tx - agent.x;
  const dy = ty - agent.y;
  const dist = Math.sqrt(dx*dx + dy*dy);
  if (dist < 5) {
    agent.currentLocation = agent.targetLocation;
    agent.targetLocation = null;
    agent.x = tx; agent.y = ty;
    return;
  }
  const speed = 2.5;
  agent.x += (dx / dist) * speed;
  agent.y += (dy / dist) * speed;
}

// ---- Logging ----
function addLog(agent, text, type = 'event') {
  const entry = { time: formatTime(simState.time), agent: agent.name, emoji: agent.emoji, text, type };
  simState.logs.push(entry);
  if (simState.logs.length > 200) simState.logs = simState.logs.slice(-150);
  renderLog(entry);
}

function renderLog(entry) {
  const panel = document.getElementById('logPanel');
  const div = document.createElement('div');
  div.className = `log-entry ${entry.type}`;
  div.innerHTML = `<span class="log-time">${entry.time.split('Â·')[1]?.trim() || ''}</span>
    <span class="log-agent">${entry.emoji}${entry.agent}</span>
    <span class="log-text">${entry.text}</span>`;
  panel.appendChild(div);
  panel.scrollTop = panel.scrollHeight;
}

// ---- Rendering ----
const canvas = document.getElementById('mapCanvas');
const ctx = canvas.getContext('2d');

function resizeCanvas() {
  const container = canvas.parentElement;
  canvas.width = container.clientWidth;
  canvas.height = container.clientHeight;
}

function drawMap() {
  resizeCanvas();
  ctx.clearRect(0, 0, canvas.width, canvas.height);

  // Draw roads
  ctx.strokeStyle = '#2a3a4a';
  ctx.lineWidth = 20;
  ctx.lineCap = 'round';
  // Horizontal roads
  [170, 290, 420].forEach(y => { ctx.beginPath(); ctx.moveTo(40, y); ctx.lineTo(560, y); ctx.stroke(); });
  // Vertical roads
  [180, 360].forEach(x => { ctx.beginPath(); ctx.moveTo(x, 50); ctx.lineTo(x, 520); ctx.stroke(); });
  ctx.strokeStyle = '#3a4a5a';
  ctx.lineWidth = 1;
  ctx.setLineDash([8, 8]);
  [170, 290, 420].forEach(y => { ctx.beginPath(); ctx.moveTo(40, y); ctx.lineTo(560, y); ctx.stroke(); });
  [180, 360].forEach(x => { ctx.beginPath(); ctx.moveTo(x, 50); ctx.lineTo(x, 520); ctx.stroke(); });
  ctx.setLineDash([]);

  // Draw locations
  LOCATIONS.forEach(loc => {
    // Shadow
    ctx.fillStyle = 'rgba(0,0,0,0.3)';
    ctx.fillRect(loc.x + 3, loc.y + 3, loc.w, loc.h);
    // Building
    ctx.fillStyle = loc.color;
    ctx.globalAlpha = 0.7;
    ctx.fillRect(loc.x, loc.y, loc.w, loc.h);
    ctx.globalAlpha = 1;
    ctx.strokeStyle = loc.color;
    ctx.lineWidth = 2;
    ctx.strokeRect(loc.x, loc.y, loc.w, loc.h);
    // Label
    ctx.fillStyle = '#fff';
    ctx.font = '12px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(loc.name, loc.x + loc.w/2, loc.y + loc.h/2 + 4);
  });

  // Draw agents
  simState.agents.forEach(agent => {
    const isSelected = simState.selectedAgent === agent.id;
    // Glow
    if (isSelected) {
      ctx.beginPath();
      ctx.arc(agent.x, agent.y, 18, 0, Math.PI * 2);
      ctx.fillStyle = 'rgba(79,195,247,0.3)';
      ctx.fill();
    }
    // Agent dot
    ctx.beginPath();
    ctx.arc(agent.x, agent.y, 12, 0, Math.PI * 2);
    ctx.fillStyle = isSelected ? '#4fc3f7' : '#fff';
    ctx.fill();
    ctx.strokeStyle = isSelected ? '#4fc3f7' : '#546e7a';
    ctx.lineWidth = 2;
    ctx.stroke();
    // Emoji
    ctx.font = '14px system-ui';
    ctx.textAlign = 'center';
    ctx.fillText(agent.emoji, agent.x, agent.y + 5);
    // Name
    ctx.fillStyle = isSelected ? '#4fc3f7' : '#90a4ae';
    ctx.font = '11px system-ui';
    ctx.fillText(agent.name, agent.x, agent.y - 16);
  });

  // Time overlay
  const h = simState.time.hour;
  if (h >= 20 || h < 6) {
    ctx.fillStyle = `rgba(0,0,30,${h >= 22 || h < 4 ? 0.4 : 0.2})`;
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
}

// ---- Sidebar ----
function renderSidebar() {
  const sidebar = document.getElementById('sidebar');
  sidebar.innerHTML = '<h3>ğŸ‘¥ å°é•‡å±…æ°‘</h3>';
  simState.agents.forEach(agent => {
    const card = document.createElement('div');
    card.className = `agent-card${simState.selectedAgent === agent.id ? ' selected' : ''}`;
    const locName = LOCATIONS.find(l => l.id === agent.currentLocation)?.name || '?';
    card.innerHTML = `
      <div class="name"><span class="emoji">${agent.emoji}</span>${agent.name}</div>
      <div class="status">ğŸ“Œ ${agent.currentAction}</div>
      <div class="mood">ğŸ’­ ${agent.mood}</div>
      <div class="location">ğŸ“ ${locName}</div>`;
    card.onclick = () => { simState.selectedAgent = agent.id; renderSidebar(); renderRightPanel(); };
    sidebar.appendChild(card);
  });
}

// ---- Right Panel (Agent Detail) ----
function renderRightPanel() {
  const panel = document.getElementById('rightPanel');
  const agent = simState.agents.find(a => a.id === simState.selectedAgent);
  if (!agent) {
    panel.innerHTML = '<h3>ğŸ§  é€‰ä¸­å±…æ°‘è¯¦æƒ…</h3><div style="font-size:13px;color:var(--text2);">ç‚¹å‡»å·¦ä¾§å±…æ°‘æŸ¥çœ‹è¯¦æƒ…</div>';
    return;
  }
  const recentMem = agent.memory.getRecentStream(6);
  const reflections = agent.memory.reflections.slice(-3);
  const locName = LOCATIONS.find(l => l.id === agent.currentLocation)?.name || '?';

  panel.innerHTML = `
    <h3>ğŸ§  ${agent.emoji} ${agent.name}</h3>
    <div style="font-size:12px;color:var(--text2);line-height:1.6;">
      ${agent.age}å² Â· ${agent.occupation}<br>
      ğŸ“ ${locName} Â· ğŸ’­ ${agent.mood}
    </div>
    ${agent.currentThought ? `
    <div class="thought-bubble">
      <div class="label">ğŸ’­ å½“å‰æƒ³æ³•</div>
      <div class="content">${agent.currentThought}</div>
    </div>` : ''}
    <div class="memory-section">
      <h4>ğŸ“ è¿‘æœŸè®°å¿† (memory/Day${simState.time.day}.md)</h4>
      ${recentMem.map(m => `<div class="memory-item"><span class="time">${m.time}</span> ${m.text}</div>`).join('') || '<div class="memory-item">æš‚æ— </div>'}
    </div>
    ${reflections.length > 0 ? `
    <div class="memory-section">
      <h4>ğŸ”® åæ€ (MEMORY.md)</h4>
      ${reflections.map(m => `<div class="memory-item"><span class="time">${m.time}</span> ${m.text}</div>`).join('')}
    </div>` : ''}
    <div class="memory-section">
      <h4>ğŸ“Š è®°å¿†ç»Ÿè®¡</h4>
      <div class="memory-item">è§‚å¯Ÿæµ: ${agent.memory.stream.length} æ¡</div>
      <div class="memory-item">æ—¥å¿—å¤©æ•°: ${Object.keys(agent.memory.dailyLogs).length}</div>
      <div class="memory-item">é•¿æœŸè®°å¿†: ${agent.memory.longTerm.length} æ¡</div>
      <div class="memory-item">åæ€æ¬¡æ•°: ${agent.memory.reflections.length}</div>
    </div>`;
}

// ---- Main Loop ----
let lastActionTime = {};
let lastConversationCheck = 0;
let animFrame = null;

async function tick() {
  if (!simState.running) return;

  advanceTime(1);
  document.getElementById('timeDisplay').textContent = formatTime(simState.time);

  // Move agents
  simState.agents.forEach(agent => {
    moveAgent(agent);
    if (agent.conversationCooldown > 0) agent.conversationCooldown--;
  });

  // Agent decisions every ~15 sim minutes
  for (const agent of simState.agents) {
    const lastTime = lastActionTime[agent.id] || 0;
    if (simState.time.total - lastTime >= 15) {
      lastActionTime[agent.id] = simState.time.total;
      decideAction(agent); // async, fires and continues
    }
  }

  // Conversation check every ~6 sim minutes
  if (simState.time.total - lastConversationCheck >= 6) {
    lastConversationCheck = simState.time.total;
    // Check for agents in same location
    const locGroups = {};
    simState.agents.forEach(a => {
      if (a.currentAction === 'ç¡è§‰') return;
      if (!locGroups[a.currentLocation]) locGroups[a.currentLocation] = [];
      locGroups[a.currentLocation].push(a);
    });
    for (const [, group] of Object.entries(locGroups)) {
      if (group.length >= 2) {
        // Try all pairs in this location (each pair has 65% chance)
        for (let i = 0; i < group.length; i++) {
          for (let j = i + 1; j < group.length; j++) {
            if (Math.random() < 0.65) {
              generateConversation(group[i], group[j]); // async
            }
          }
        }
      }
    }
  }

  // Reflection check every ~60 sim minutes
  if (simState.time.total % 60 === 0) {
    for (const agent of simState.agents) {
      reflect(agent); // async
    }
  }

  // Render
  drawMap();
  renderSidebar();
  if (simState.selectedAgent) renderRightPanel();
}

function gameLoop() {
  if (!simState.running) return;
  const speed = simState.speed;
  for (let i = 0; i < speed; i++) tick();
  animFrame = requestAnimationFrame(gameLoop);
}

// ---- Initialization ----
function initSimulation() {
  simState.agents = AGENT_TEMPLATES.map(t => new Agent(t));
  simState.time = { day: 1, hour: 6, minute: 0, total: 360 };
  simState.logs = [];
  simState.selectedAgent = null;
  lastActionTime = {};
  lastConversationCheck = 0;
  document.getElementById('logPanel').innerHTML = '<h3>ğŸ“œ å°é•‡æ—¥å¿—</h3>';
  addLog({ name: 'ç³»ç»Ÿ', emoji: 'ğŸ˜ï¸' }, 'å°é•‡è‹é†’äº†ï¼æ–°çš„ä¸€å¤©å¼€å§‹ã€‚', 'event');
  renderSidebar();
  drawMap();
}

function startSimulation() {
  simState.running = true;
  document.getElementById('btnPlay').classList.add('active');
  document.getElementById('btnPause').classList.remove('active');
  gameLoop();
}

function pauseSimulation() {
  simState.running = false;
  document.getElementById('btnPlay').classList.remove('active');
  document.getElementById('btnPause').classList.add('active');
  if (animFrame) cancelAnimationFrame(animFrame);
}

function resetSimulation() {
  pauseSimulation();
  initSimulation();
}

// ---- Event Handlers ----
document.getElementById('btnPlay').onclick = startSimulation;
document.getElementById('btnPause').onclick = pauseSimulation;
document.getElementById('btnReset').onclick = resetSimulation;
document.getElementById('speedSelect').onchange = (e) => { simState.speed = parseInt(e.target.value); };

// Canvas click to select agent
canvas.onclick = (e) => {
  const rect = canvas.getBoundingClientRect();
  const mx = e.clientX - rect.left;
  const my = e.clientY - rect.top;
  let found = null;
  simState.agents.forEach(agent => {
    const dx = mx - agent.x;
    const dy = my - agent.y;
    if (dx*dx + dy*dy < 400) found = agent.id;
  });
  simState.selectedAgent = found;
  renderSidebar();
  renderRightPanel();
};

// API key modal
function startWithApi() {
  const key = document.getElementById('apiKeyInput').value.trim();
  if (!key) { alert('è¯·è¾“å…¥ API Key'); return; }
  CONFIG.apiKey = key;
  CONFIG.demoMode = false;
  document.getElementById('apiModal').classList.add('hidden');
  initSimulation();
  startSimulation();
}

function startWithDemo() {
  CONFIG.demoMode = true;
  document.getElementById('apiModal').classList.add('hidden');
  initSimulation();
  startSimulation();
}

// Check for saved key
const savedKey = localStorage.getItem('qwen_api_key');
if (savedKey) document.getElementById('apiKeyInput').value = savedKey;

// Window resize
window.addEventListener('resize', drawMap);

// Initial render
resizeCanvas();
drawMap();
</script>
</body>
</html>
