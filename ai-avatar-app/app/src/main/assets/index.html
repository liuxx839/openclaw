<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no,viewport-fit=cover">
<title>AI Avatar</title>
<style>
*{box-sizing:border-box;margin:0;padding:0;-webkit-tap-highlight-color:transparent}
:root{--bg:#0d1117;--bg2:#161b22;--card:#1c2333;--accent:#6c9fff;--accent2:#4a7fff;--purple:#a78bfa;--warm:#ffb347;--green:#4ade80;--red:#f87171;--pink:#f472b6;--text:#e6edf3;--text2:#8b949e;--text3:#484f58;--border:#30363d;--r:14px}
body{font-family:-apple-system,system-ui,sans-serif;background:var(--bg);color:var(--text);min-height:100vh;overflow-x:hidden;padding-bottom:env(safe-area-inset-bottom)}
/* Nav */
.nav{position:fixed;bottom:0;left:0;right:0;background:var(--bg2);border-top:1px solid var(--border);display:flex;z-index:100;padding-bottom:env(safe-area-inset-bottom)}
.nav-item{flex:1;display:flex;flex-direction:column;align-items:center;padding:8px 0 4px;font-size:10px;color:var(--text3);cursor:pointer;transition:.2s}
.nav-item.on{color:var(--accent)}.nav-item .ni{font-size:20px;margin-bottom:2px}
/* Pages */
.page{display:none;min-height:100vh;padding:16px 16px 80px}
.page.on{display:block}
/* Avatar */
.avatar-wrap{display:flex;flex-direction:column;align-items:center;padding-top:20px}
.avatar-circle{width:200px;height:200px;border-radius:50%;overflow:hidden;background:#000;box-shadow:0 10px 40px rgba(0,0,0,.5);position:relative;margin-bottom:16px}
.avatar-circle video{width:100%;height:100%;object-fit:cover;position:absolute;top:0;left:0}
.avatar-circle .ph{width:100%;height:100%;display:flex;align-items:center;justify-content:center;font-size:80px;background:linear-gradient(135deg,#667eea,#764ba2)}
/* Mic btn */
.mic-area{text-align:center;margin:20px 0}
.mic-btn{width:72px;height:72px;border-radius:50%;border:none;font-size:28px;cursor:pointer;background:linear-gradient(135deg,#667eea,#764ba2);color:#fff;box-shadow:0 6px 20px rgba(102,126,234,.4);transition:.2s}
.mic-btn.recording{background:linear-gradient(135deg,#ff416c,#ff4b2b);animation:pulse 1.5s infinite}
.mic-btn:disabled{background:#333;cursor:not-allowed;box-shadow:none}
@keyframes pulse{0%,100%{box-shadow:0 0 0 0 rgba(255,65,108,.4)}50%{box-shadow:0 0 0 16px rgba(255,65,108,0)}}
.status-line{font-size:12px;color:var(--text2);margin-top:8px;text-align:center}
.session-badge{font-size:11px;padding:3px 10px;border-radius:12px;display:inline-block;margin-top:6px}
.session-badge.active{background:rgba(74,222,128,.15);color:var(--green)}
.session-badge.idle{background:rgba(139,148,158,.15);color:var(--text2)}
/* Chat area */
.chat-area{margin-top:16px;max-height:300px;overflow-y:auto;background:var(--card);border-radius:var(--r);padding:12px}
.chat-msg{padding:6px 0;font-size:13px;line-height:1.5;border-bottom:1px solid rgba(255,255,255,.05)}
.chat-msg:last-child{border-bottom:none}
.chat-msg.user{color:var(--accent)}.chat-msg.ai{color:var(--green)}.chat-msg.sys{color:var(--text3);font-style:italic;font-size:11px}
/* Image upload */
.upload-area{margin-top:12px;display:flex;gap:8px;justify-content:center}
.up-btn{padding:8px 16px;border-radius:var(--r);border:1px dashed var(--border);background:transparent;color:var(--text2);font-size:12px;cursor:pointer}
.up-btn:active{background:var(--card)}
/* Cards */
.cards-grid{display:flex;flex-direction:column;gap:10px}
.card-item{background:var(--card);border-radius:var(--r);padding:14px;border-left:3px solid var(--accent)}
.card-item .card-time{font-size:10px;color:var(--text3)}
.card-item .card-title{font-size:14px;font-weight:600;margin:4px 0}
.card-item .card-body{font-size:12px;color:var(--text2);line-height:1.6}
.card-item .card-tags{display:flex;flex-wrap:wrap;gap:4px;margin-top:6px}
.card-item .tag{font-size:10px;background:rgba(108,159,255,.12);color:var(--accent);padding:2px 8px;border-radius:10px}
.card-actions{display:flex;gap:6px;margin-top:8px}
.card-actions button{font-size:11px;padding:4px 10px;border-radius:8px;border:1px solid var(--border);background:transparent;color:var(--text2);cursor:pointer}
/* Memory */
.mem-section{background:var(--card);border-radius:var(--r);padding:14px;margin-bottom:12px}
.mem-section h3{font-size:13px;color:var(--accent);margin-bottom:8px;display:flex;align-items:center;gap:6px}
.mem-entry{font-size:11px;color:var(--text2);padding:4px 0;border-bottom:1px solid rgba(255,255,255,.04);line-height:1.5}
.mem-entry:last-child{border-bottom:none}
.mem-entry .me-time{color:var(--warm);font-size:10px}
.mem-stats{display:grid;grid-template-columns:repeat(3,1fr);gap:8px;margin-top:10px}
.mem-stat{background:var(--bg2);border-radius:10px;padding:10px;text-align:center}
.mem-stat .ms-v{font-size:20px;font-weight:700;color:var(--accent)}.mem-stat .ms-l{font-size:9px;color:var(--text3);margin-top:2px}
/* Settings */
.set-group{background:var(--card);border-radius:var(--r);padding:14px;margin-bottom:12px}
.set-group h3{font-size:13px;color:var(--text2);margin-bottom:10px}
.set-row{display:flex;align-items:center;gap:10px;margin-bottom:10px;flex-wrap:wrap}
.set-row label{font-size:12px;color:var(--text2);min-width:70px}
.set-row input,.set-row select{flex:1;min-width:0;padding:9px 12px;border:1px solid var(--border);border-radius:10px;background:var(--bg);color:var(--text);font-size:13px;outline:none}
.set-row input:focus{border-color:var(--accent)}
.sbtn{padding:9px 18px;border:none;border-radius:10px;font-size:12px;font-weight:600;cursor:pointer;transition:.2s}
.sbtn.primary{background:linear-gradient(135deg,#667eea,#764ba2);color:#fff}
.sbtn.ghost{background:var(--bg2);color:var(--text2);border:1px solid var(--border)}
.sbtn:active{opacity:.8}
/* Page header */
.pg-header{font-size:18px;font-weight:700;margin-bottom:16px;display:flex;align-items:center;gap:8px}
/* Saveable card render */
.save-canvas{position:fixed;top:-9999px;left:-9999px}
/* Toast */
.toast{position:fixed;top:60px;left:50%;transform:translateX(-50%);background:var(--card);border:1px solid var(--border);border-radius:10px;padding:10px 20px;font-size:12px;color:var(--text);z-index:200;opacity:0;transition:opacity .3s}
.toast.show{opacity:1}
/* Camera preview */
.cam-preview{position:fixed;bottom:70px;right:12px;width:120px;height:90px;background:#000;border-radius:10px;overflow:hidden;box-shadow:0 4px 20px rgba(0,0,0,.6);opacity:0;transition:opacity .3s;z-index:50;pointer-events:none}
.cam-preview.show{opacity:1;pointer-events:auto}
.cam-preview video{width:100%;height:100%;object-fit:cover;transform:scaleX(-1)}
.cam-preview .cam-close{position:absolute;top:4px;right:4px;width:20px;height:20px;background:rgba(0,0,0,.6);border:none;color:#fff;border-radius:50%;font-size:10px;cursor:pointer;display:flex;align-items:center;justify-content:center}
/* Action buttons row */
.action-row{display:flex;gap:6px;justify-content:center;margin-top:8px;flex-wrap:wrap}
.act-btn{padding:6px 12px;border-radius:20px;border:1px solid var(--border);background:transparent;color:var(--text2);font-size:11px;cursor:pointer;transition:.2s}
.act-btn:active{background:var(--card)}
.act-btn.on{background:var(--accent2);color:#fff;border-color:var(--accent)}
</style>
</head>
<body>

<div class="page on" id="p-chat">
  <div class="avatar-wrap">
    <div class="avatar-circle" id="avatarBox">
      <div class="ph" id="avatarPh">ğŸ¤–</div>
      <video id="vIdle" loop muted playsinline autoplay style="display:none"></video>
      <video id="vTalk" loop muted playsinline style="display:none"></video>
    </div>
    <div class="session-badge idle" id="sessBadge">âšª å¾…æœºä¸­</div>
  </div>
  <div class="mic-area">
    <button class="mic-btn" id="micBtn" onclick="toggleSession()" disabled>ğŸ¤</button>
    <div class="status-line" id="statusLine">è¯·å…ˆåœ¨è®¾ç½®ä¸­è¾“å…¥ API Key</div>
  </div>
  <div class="action-row">
    <button class="act-btn" id="btnCamera" onclick="toggleCamera()">ğŸ“¹ æ‘„åƒå¤´</button>
    <button class="act-btn" onclick="uploadImage()">ğŸ–¼ï¸ å‘å›¾ç‰‡</button>
    <button class="act-btn" onclick="toggleChat()">ğŸ’¬ å¯¹è¯</button>
  </div>
  <div class="chat-area" id="chatArea" style="display:none"></div>
  <input type="file" id="imgInput" accept="image/*" style="display:none" onchange="handleImageUpload(event)">
</div>

<div class="cam-preview" id="camPreview">
  <video id="camVideo" autoplay muted playsinline></video>
  <button class="cam-close" onclick="toggleCamera()">âœ•</button>
</div>
<canvas id="frameCanvas" style="display:none"></canvas>

<div class="page" id="p-cards">
  <div class="pg-header">ğŸ“‹ å¡ç‰‡æ•´ç†</div>
  <div style="display:flex;gap:8px;margin-bottom:14px">
    <button class="sbtn primary" onclick="generateCard()">âœ¨ AI ç”Ÿæˆå¡ç‰‡</button>
    <button class="sbtn ghost" onclick="clearCards()">ğŸ—‘ï¸ æ¸…ç©º</button>
  </div>
  <div class="cards-grid" id="cardsGrid"></div>
</div>

<div class="page" id="p-memory">
  <div class="pg-header">ğŸ§  è®°å¿†ç³»ç»Ÿ</div>
  <div class="mem-section">
    <h3>ğŸ“ çŸ­æœŸè®°å¿† (Daily Log)</h3>
    <div id="shortMem">æš‚æ— </div>
  </div>
  <div class="mem-section">
    <h3>ğŸ’ é•¿æœŸè®°å¿† (MEMORY.md)</h3>
    <div id="longMem">æš‚æ— </div>
  </div>
  <div class="mem-section">
    <h3>ğŸ”® åæ€æ‘˜è¦</h3>
    <div id="refMem">æš‚æ— </div>
  </div>
  <div class="mem-stats">
    <div class="mem-stat"><div class="ms-v" id="msObs">0</div><div class="ms-l">è§‚å¯Ÿ</div></div>
    <div class="mem-stat"><div class="ms-v" id="msDays">0</div><div class="ms-l">å¤©æ•°</div></div>
    <div class="mem-stat"><div class="ms-v" id="msRef">0</div><div class="ms-l">åæ€</div></div>
  </div>
  <div style="margin-top:12px;display:flex;gap:8px">
    <button class="sbtn ghost" onclick="manualFlush()">ğŸ“ ç«‹å³æ€»ç»“</button>
    <button class="sbtn ghost" onclick="exportMemory()">ğŸ“¤ å¯¼å‡ºè®°å¿†</button>
  </div>
</div>

<div class="page" id="p-settings">
  <div class="pg-header">âš™ï¸ è®¾ç½®</div>
  <div class="set-group">
    <h3>ğŸ”‘ API é…ç½®</h3>
    <div class="set-row">
      <label>API Key:</label>
      <input type="password" id="sApiKey" placeholder="sk-xxxxxxxx">
    </div>
    <button class="sbtn primary" onclick="saveSettings()" style="width:100%">ä¿å­˜</button>
  </div>
  <div class="set-group">
    <h3>ğŸ—£ï¸ æ¿€æ´»è®¾ç½®</h3>
    <div class="set-row">
      <label>æ¿€æ´»è¯:</label>
      <input type="text" id="sWakeWords" placeholder="å°åŠ©æ‰‹,ä½ å¥½,å—¨ï¼ˆé€—å·åˆ†éš”ï¼‰">
    </div>
    <div class="set-row">
      <label>ä¿æŒè½®æ•°:</label>
      <input type="text" id="sKeepTurns" placeholder="5" value="5">
    </div>
    <div class="set-row">
      <label>è¯­éŸ³:</label>
      <select id="sVoice">
        <option value="Serena">Serenaï¼ˆå¥³å£°ï¼‰</option>
        <option value="Ethan">Ethanï¼ˆç”·å£°ï¼‰</option>
        <option value="Chelsie">Chelsie</option>
      </select>
    </div>
    <button class="sbtn primary" onclick="saveSettings()" style="width:100%">ä¿å­˜</button>
  </div>
  <div class="set-group">
    <h3>ğŸ¬ å¤´åƒè§†é¢‘</h3>
    <div class="set-row">
      <button class="sbtn ghost" onclick="selectVideos()" style="width:100%">é€‰æ‹©è§†é¢‘æ–‡ä»¶ï¼ˆidle + talkï¼‰</button>
    </div>
    <div id="videoStat" style="font-size:11px;color:var(--text3)"></div>
    <input type="file" id="vidInput" accept="video/*" multiple style="display:none" onchange="handleVideoSelect(event)">
  </div>
  <div class="set-group">
    <h3>ğŸ“Š å…³äº</h3>
    <div style="font-size:11px;color:var(--text3);line-height:1.8">
      AI Avatar v1.0<br>
      æ¨¡å‹ï¼šqwen3-omni-flash-realtime / qwen-plus<br>
      ASRï¼šqwen3-asr-flash-realtime<br>
      è®°å¿†ç³»ç»Ÿï¼šåŸºäº OpenClaw æ¨¡å¼
    </div>
  </div>
</div>

<div class="nav">
  <div class="nav-item on" data-p="p-chat"><div class="ni">ğŸ¤</div>å¯¹è¯</div>
  <div class="nav-item" data-p="p-cards"><div class="ni">ğŸ“‹</div>å¡ç‰‡</div>
  <div class="nav-item" data-p="p-memory"><div class="ni">ğŸ§ </div>è®°å¿†</div>
  <div class="nav-item" data-p="p-settings"><div class="ni">âš™ï¸</div>è®¾ç½®</div>
</div>

<div class="toast" id="toast"></div>
<canvas class="save-canvas" id="saveCanvas"></canvas>

<script>
// ============================================================
// AI Avatar Mobile App
// Memory system inspired by OpenClaw:
// - Daily logs (memory/YYYY-MM-DD.md)
// - Long-term curated memory (MEMORY.md)
// - Pre-compaction flush
// - Importance-weighted retrieval
// ============================================================

// ---- Config ----
let CFG = {
  apiKey: localStorage.getItem('av_apikey') || '',
  wakeWords: (localStorage.getItem('av_wake') || 'å°åŠ©æ‰‹,ä½ å¥½,å—¨').split(',').map(w => w.trim()).filter(Boolean),
  keepTurns: parseInt(localStorage.getItem('av_turns') || '5'),
  voice: localStorage.getItem('av_voice') || 'Serena',
  summaryInterval: 60000,
};
const GOODBYE = ['æ‹œæ‹œ','å¥½äº†','è°¢è°¢','å†è§','åœåœ','æ²¡äº‹äº†','å°±è¿™æ ·'];
const OMNI_MODEL = 'qwen3-omni-flash-realtime-2025-12-01';

// ---- Memory System (OpenClaw-inspired) ----
class MemorySystem {
  constructor() {
    this.stream = [];       // short-term observation stream
    this.dailyLogs = {};    // memory/DayN pattern
    this.longTerm = [];     // MEMORY.md pattern
    this.reflections = [];  // compaction outputs
    this.importance = new Map();
    this.load();
  }
  save() {
    try {
      localStorage.setItem('av_mem', JSON.stringify({
        stream: this.stream.slice(-100),
        dailyLogs: this.dailyLogs,
        longTerm: this.longTerm.slice(-50),
        reflections: this.reflections.slice(-20),
      }));
    } catch {}
  }
  load() {
    try {
      const d = JSON.parse(localStorage.getItem('av_mem') || 'null');
      if (d) {
        this.stream = d.stream || [];
        this.dailyLogs = d.dailyLogs || {};
        this.longTerm = d.longTerm || [];
        this.reflections = d.reflections || [];
        [...this.stream, ...this.reflections].forEach(m => this.importance.set(m.text, m.imp || 5));
      }
    } catch {}
  }
  addObs(text, imp = 5) {
    const now = new Date();
    const entry = { text, time: fmtDate(now), ts: now.getTime(), imp };
    this.stream.push(entry);
    this.importance.set(text, imp);
    const dk = now.toISOString().split('T')[0];
    if (!this.dailyLogs[dk]) this.dailyLogs[dk] = [];
    this.dailyLogs[dk].push(entry);
    this.save();
  }
  addReflection(text) {
    const now = new Date();
    const entry = { text, time: fmtDate(now), ts: now.getTime(), imp: 8 };
    this.reflections.push(entry);
    this.longTerm.push(entry);
    this.importance.set(text, 8);
    this.save();
  }
  getRecent(n = 10) { return this.stream.slice(-n); }
  getLongTerm() { return this.longTerm.slice(-10).map(m => m.text); }
  getTodayLog() {
    const dk = new Date().toISOString().split('T')[0];
    return this.dailyLogs[dk] || [];
  }
  retrieve(query, n = 5) {
    const now = Date.now();
    return [...this.stream, ...this.reflections].map(m => {
      const rec = 1 / (1 + (now - m.ts) / 60000);
      const imp = (this.importance.get(m.text) || 5) / 10;
      const rel = simTxt(query, m.text);
      return { ...m, score: rec * .3 + imp * .3 + rel * .4 };
    }).sort((a, b) => b.score - a.score).slice(0, n);
  }
  needsFlush() { return this.stream.length > 20; }
  compact(summary) {
    this.addReflection(summary);
    this.stream = this.stream.slice(-5);
    this.save();
  }
  getStats() {
    return { obs: this.stream.length, days: Object.keys(this.dailyLogs).length, refs: this.reflections.length };
  }
  exportAll() {
    return JSON.stringify({ stream: this.stream, dailyLogs: this.dailyLogs, longTerm: this.longTerm, reflections: this.reflections }, null, 2);
  }
}
function simTxt(a, b) { const x = new Set(a.split(/\s+/)), y = new Set(b.split(/\s+/)); let o = 0; for (const t of x) if (y.has(t)) o++; return o / Math.max(x.size, y.size, 1); }
function fmtDate(d) { const p = n => String(n).padStart(2, '0'); return `${d.getFullYear()}-${p(d.getMonth() + 1)}-${p(d.getDate())} ${p(d.getHours())}:${p(d.getMinutes())}`; }

const mem = new MemorySystem();

// ---- Cards ----
let cards = JSON.parse(localStorage.getItem('av_cards') || '[]');

// ---- Audio/WS State ----
let ws = null, audioCtx = null, micProcessor = null, micSource = null, micStream = null;
let isActive = false, isGateOpen = false, audioBuffer = [], nextPlayTime = 0, activeSources = [];
let sessState = { active: false, turns: 0 };

// ---- Nav ----
document.querySelectorAll('.nav-item').forEach(ni => {
  ni.onclick = () => {
    document.querySelectorAll('.nav-item').forEach(x => x.classList.remove('on'));
    document.querySelectorAll('.page').forEach(x => x.classList.remove('on'));
    ni.classList.add('on');
    document.getElementById(ni.dataset.p).classList.add('on');
    if (ni.dataset.p === 'p-memory') renderMemory();
    if (ni.dataset.p === 'p-cards') renderCards();
  };
});

// ---- Init ----
window.addEventListener('load', () => {
  if (CFG.apiKey) {
    document.getElementById('sApiKey').value = CFG.apiKey;
    document.getElementById('micBtn').disabled = false;
    document.getElementById('statusLine').textContent = 'å‡†å¤‡å°±ç»ªï¼Œç‚¹å‡»å¼€å§‹';
  }
  document.getElementById('sWakeWords').value = CFG.wakeWords.join(',');
  document.getElementById('sKeepTurns').value = CFG.keepTurns;
  document.getElementById('sVoice').value = CFG.voice;
  renderCards();

  // Auto-load bundled avatar videos
  const vIdle = document.getElementById('vIdle');
  const vTalk = document.getElementById('vTalk');
  vIdle.src = 'pause.mp4';
  vTalk.src = 'talk.mp4';
  vIdle.oncanplay = () => {
    hasVideos = true; pauseUrl = 'pause.mp4'; talkUrl = 'talk.mp4';
    document.getElementById('avatarPh').style.display = 'none';
    vIdle.style.display = 'block';
    vIdle.play().catch(() => {});
    document.getElementById('videoStat').textContent = 'âœ“ å†…ç½®è§†é¢‘å·²åŠ è½½';
  };
});

function saveSettings() {
  const oldVoice = CFG.voice;
  CFG.apiKey = document.getElementById('sApiKey').value.trim();
  CFG.wakeWords = document.getElementById('sWakeWords').value.split(',').map(w => w.trim()).filter(Boolean);
  CFG.keepTurns = parseInt(document.getElementById('sKeepTurns').value) || 5;
  CFG.voice = document.getElementById('sVoice').value;
  localStorage.setItem('av_apikey', CFG.apiKey);
  localStorage.setItem('av_wake', CFG.wakeWords.join(','));
  localStorage.setItem('av_turns', CFG.keepTurns);
  localStorage.setItem('av_voice', CFG.voice);
  document.getElementById('micBtn').disabled = !CFG.apiKey;
  if (CFG.apiKey) document.getElementById('statusLine').textContent = 'å‡†å¤‡å°±ç»ª';

  // Live-apply: if Omni session is active, push updated settings immediately
  if (ws && ws.readyState === WebSocket.OPEN) {
    ws.send(JSON.stringify({
      type: 'session.update',
      session: {
        voice: CFG.voice,
        instructions: buildSysPrompt(),
      }
    }));
    toast('è®¾ç½®å·²ä¿å­˜å¹¶å®æ—¶ç”Ÿæ•ˆ');
  } else {
    toast('è®¾ç½®å·²ä¿å­˜');
  }
}

// ---- Video ----
let hasVideos = false, talkUrl = null, pauseUrl = null;
function selectVideos() { document.getElementById('vidInput').click(); }
function handleVideoSelect(e) {
  for (const f of e.target.files) {
    const url = URL.createObjectURL(f);
    const nm = f.name.toLowerCase();
    if (nm.includes('talk')) { talkUrl = url; document.getElementById('vTalk').src = url; }
    else { pauseUrl = url; document.getElementById('vIdle').src = url; }
  }
  if (pauseUrl) {
    hasVideos = true;
    document.getElementById('avatarPh').style.display = 'none';
    document.getElementById('vIdle').style.display = 'block';
    document.getElementById('vIdle').play().catch(() => {});
    document.getElementById('videoStat').textContent = 'âœ“ è§†é¢‘å·²åŠ è½½';
  }
}
function setAvatar(state) {
  if (!hasVideos) { document.getElementById('avatarPh').textContent = state === 'talk' ? 'ğŸ—£ï¸' : 'ğŸ¤–'; return; }
  const vi = document.getElementById('vIdle'), vt = document.getElementById('vTalk');
  if (state === 'talk' && talkUrl) { vi.style.display = 'none'; vi.pause(); vt.style.display = 'block'; vt.play().catch(() => {}); }
  else { vt.style.display = 'none'; vt.pause(); vi.style.display = 'block'; vi.play().catch(() => {}); }
}

// ---- Session ----
function activateSess() { sessState.active = true; sessState.turns = CFG.keepTurns; updateBadge(); }
function deactivateSess() { sessState.active = false; sessState.turns = 0; isGateOpen = false; updateBadge(); }
function consumeTurn() { if (sessState.turns > 0) { sessState.turns--; updateBadge(); if (sessState.turns <= 0) deactivateSess(); } }
function updateBadge() {
  const b = document.getElementById('sessBadge');
  if (sessState.active) { b.className = 'session-badge active'; b.textContent = `ğŸŸ¢ æ¿€æ´» (${sessState.turns}è½®)`; }
  else { b.className = 'session-badge idle'; b.textContent = 'âšª ç›‘å¬ä¸­'; }
}
function shouldRespond(text) {
  if (GOODBYE.some(w => text.includes(w))) return { respond: true, bye: true };
  if (CFG.wakeWords.some(w => text.includes(w))) { activateSess(); return { respond: true, wake: true }; }
  if (sessState.active) return { respond: true };
  return { respond: false };
}

// ---- Chat ----
let chatVisible = false;
function toggleChat() { chatVisible = !chatVisible; document.getElementById('chatArea').style.display = chatVisible ? 'block' : 'none'; }
function addChat(role, text) {
  const el = document.getElementById('chatArea');
  const d = document.createElement('div');
  d.className = `chat-msg ${role}`;
  d.textContent = (role === 'user' ? 'ğŸ§‘ ' : role === 'ai' ? 'ğŸ¤– ' : '') + text;
  el.appendChild(d);
  el.scrollTop = el.scrollHeight;
  while (el.children.length > 30) el.removeChild(el.firstChild);
}

// ---- Camera + Image (input_image_buffer.append, same as original ai_avatar.html) ----
let cameraStream = null;
let videoFrameInterval = null;
let hasAudioSent = false;
let lastImageContext = '';

function toggleCamera() {
  if (cameraStream) { stopCamera(); } else { startCamera(); }
}

async function startCamera() {
  try {
    cameraStream = await navigator.mediaDevices.getUserMedia({ video: { width: 640, height: 480 }, audio: false });
    document.getElementById('camVideo').srcObject = cameraStream;
    document.getElementById('camPreview').classList.add('show');
    document.getElementById('btnCamera').classList.add('on');
    // Send frames at 2fps to Omni via input_image_buffer.append
    videoFrameInterval = setInterval(sendVideoFrame, 500);
    addChat('sys', 'ğŸ“¹ æ‘„åƒå¤´å·²æ‰“å¼€ï¼ŒAI å¯ä»¥çœ‹åˆ°ä½ äº†');
    mem.addObs('ç”¨æˆ·æ‰“å¼€äº†æ‘„åƒå¤´', 5);
  } catch (e) {
    toast('æ‘„åƒå¤´æ‰“å¼€å¤±è´¥: ' + e.message);
  }
}

function stopCamera() {
  if (videoFrameInterval) { clearInterval(videoFrameInterval); videoFrameInterval = null; }
  if (cameraStream) { cameraStream.getTracks().forEach(t => t.stop()); cameraStream = null; }
  document.getElementById('camVideo').srcObject = null;
  document.getElementById('camPreview').classList.remove('show');
  document.getElementById('btnCamera').classList.remove('on');
  addChat('sys', 'ğŸ“¹ æ‘„åƒå¤´å·²å…³é—­');
}

// Send video frame to Omni (same protocol as original ai_avatar.html)
function sendVideoFrame() {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  if (!hasAudioSent) return; // Must send audio first per DashScope spec
  const video = document.getElementById('camVideo');
  if (!video.videoWidth || !video.videoHeight) return;
  try {
    const canvas = document.getElementById('frameCanvas');
    const ctx = canvas.getContext('2d');
    canvas.width = 640; canvas.height = 480;
    ctx.drawImage(video, 0, 0, 640, 480);
    let quality = 0.6;
    let dataURL = canvas.toDataURL('image/jpeg', quality);
    let b64 = dataURL.split(',')[1];
    const maxSize = 450 * 1024;
    while (b64.length > maxSize && quality > 0.2) {
      quality -= 0.1;
      dataURL = canvas.toDataURL('image/jpeg', quality);
      b64 = dataURL.split(',')[1];
    }
    ws.send(JSON.stringify({ type: 'input_image_buffer.append', image: b64 }));
  } catch (e) { console.error('Send frame failed:', e); }
}

// Upload static image â†’ also send to Omni via input_image_buffer.append
function uploadImage() { document.getElementById('imgInput').click(); }
function handleImageUpload(e) {
  const file = e.target.files[0]; if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    addChat('user', `[ğŸ–¼ï¸ å›¾ç‰‡: ${file.name}]`);
    mem.addObs(`ç”¨æˆ·ä¸Šä¼ äº†å›¾ç‰‡: ${file.name}`, 6);

    // Resize image to 640x480 and send to Omni directly
    const img = new Image();
    img.onload = () => {
      const canvas = document.getElementById('frameCanvas');
      const ctx = canvas.getContext('2d');
      canvas.width = 640; canvas.height = 480;
      // Fit image maintaining aspect ratio
      const scale = Math.min(640 / img.width, 480 / img.height);
      const w = img.width * scale, h = img.height * scale;
      ctx.fillStyle = '#000'; ctx.fillRect(0, 0, 640, 480);
      ctx.drawImage(img, (640 - w) / 2, (480 - h) / 2, w, h);
      const b64 = canvas.toDataURL('image/jpeg', 0.7).split(',')[1];

      if (ws && ws.readyState === WebSocket.OPEN && hasAudioSent) {
        // Send image frame to Omni (same as camera frame)
        ws.send(JSON.stringify({ type: 'input_image_buffer.append', image: b64 }));
        addChat('sys', 'ğŸ–¼ï¸ å›¾ç‰‡å·²å‘é€ç»™ AIï¼ˆé€šè¿‡è§†è§‰é€šé“ï¼‰');
        // Also send a text hint so AI knows to describe it
        ws.send(JSON.stringify({
          type: 'conversation.item.create',
          item: { type: 'message', role: 'user', content: [{ type: 'input_text', text: 'æˆ‘åˆšå‘äº†ä¸€å¼ å›¾ç‰‡ç»™ä½ ï¼Œè¯·çœ‹ä¸€ä¸‹å¹¶æè¿°ä½ çœ‹åˆ°äº†ä»€ä¹ˆã€‚' }] }
        }));
        ws.send(JSON.stringify({ type: 'response.create' }));
      } else {
        // Omni not connected, fallback to qwen-vl-plus API
        fallbackImageAnalysis(ev.target.result.split(',')[1]);
      }
    };
    img.src = ev.target.result;
  };
  reader.readAsDataURL(file);
  e.target.value = '';
}

async function fallbackImageAnalysis(base64) {
  addChat('sys', 'ğŸ” Omni æœªè¿æ¥ï¼Œä½¿ç”¨è§†è§‰æ¨¡å‹åˆ†æ...');
  try {
    const resp = await fetch('https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${CFG.apiKey}` },
      body: JSON.stringify({
        model: 'qwen-vl-plus',
        messages: [{ role: 'user', content: [
          { type: 'image_url', image_url: { url: `data:image/jpeg;base64,${base64}` } },
          { type: 'text', text: 'è¯·æè¿°è¿™å¼ å›¾ç‰‡çš„å†…å®¹ã€‚' }
        ] }],
        max_tokens: 300
      })
    });
    const data = await resp.json();
    const desc = data.choices?.[0]?.message?.content || 'æ— æ³•è¯†åˆ«';
    addChat('ai', desc);
    mem.addObs(`å›¾ç‰‡è¯†åˆ«: ${desc}`, 7);
    lastImageContext = desc;
  } catch (err) { addChat('sys', 'åˆ†æå¤±è´¥: ' + err.message); }
}

// ---- System Prompt ----
function buildSysPrompt() {
  const shortMem = mem.getRecent(15).map(m => `[${m.time}] ${m.text}`).join('\n');
  const longMem = mem.getLongTerm().join('\n');
  const todayLog = mem.getTodayLog().map(m => `[${m.time}] ${m.text}`).join('\n');
  return `ä½ æ˜¯AIåŠ©ç†"å°åŠ©æ‰‹"ã€‚

### æ ¸å¿ƒæŒ‡ä»¤ ###
1. é™é»˜åŸåˆ™ï¼šæœªè¢«å”¤é†’æ—¶ä¿æŒå®‰é™ã€‚
2. è¢«å”¤é†’åç®€çŸ­å›ç­”ï¼ˆ30å­—å†…ï¼‰ï¼Œä¸è¦å•°å—¦ã€‚
3. ä¼šè¯ä¿æŒï¼šå”¤é†’åä¿æŒå‡ è½®å¯¹è¯ã€‚

### å”¤é†’è¯ ###
${JSON.stringify(CFG.wakeWords)}

### ä»Šæ—¥å¯¹è¯è®°å½• ###
${todayLog || 'æš‚æ— '}

### çŸ­æœŸè®°å¿† ###
${shortMem || 'æš‚æ— '}

### é•¿æœŸè®°å¿† ###
${longMem || 'æš‚æ— '}

### æœ€è¿‘å›¾ç‰‡ä¸Šä¸‹æ–‡ ###
${lastImageContext ? `ç”¨æˆ·åˆšä¸Šä¼ äº†ä¸€å¼ å›¾ç‰‡ï¼Œå†…å®¹æ˜¯ï¼š${lastImageContext}` : 'æš‚æ— å›¾ç‰‡'}

### å›ç­”è§„åˆ™ ###
- é—®"åˆšæ‰è¯´äº†ä»€ä¹ˆ"ï¼šå‚è€ƒå¯¹è¯è®°å½•å’ŒçŸ­æœŸè®°å¿†
- é—®åˆ°å›¾ç‰‡ç›¸å…³å†…å®¹ï¼šå‚è€ƒ"æœ€è¿‘å›¾ç‰‡ä¸Šä¸‹æ–‡"
- é—®å€™è¯­ï¼šä¸€å¥è¯äº²åˆ‡å›åº”
- å‘Šåˆ«è¯­ï¼ˆå†è§/æ‹œæ‹œï¼‰ï¼šæ¸©æš–å‘Šåˆ«
- å…¶ä»–ï¼šä¸“ä¸šç®€çŸ­å›ç­”`;
}

// ---- WebSocket Session ----
async function toggleSession() {
  if (isActive) { stopSession(); } else { await startSession(); }
}

async function startSession() {
  if (!CFG.apiKey) { toast('è¯·å…ˆè®¾ç½® API Key'); return; }
  try {
    if (!audioCtx) { audioCtx = new (window.AudioContext || window.webkitAudioContext)({ sampleRate: 24000 }); }
    else if (audioCtx.state === 'suspended') { await audioCtx.resume(); }

    micStream = await navigator.mediaDevices.getUserMedia({ audio: { sampleRate: 16000, channelCount: 1, echoCancellation: true, noiseSuppression: true } });
    micSource = audioCtx.createMediaStreamSource(micStream);
    micProcessor = audioCtx.createScriptProcessor(4096, 1, 1);
    micSource.connect(micProcessor);
    micProcessor.connect(audioCtx.destination);

    const wsUrl = `wss://dashscope.aliyuncs.com/api-ws/v1/realtime?model=${OMNI_MODEL}&api_key=${CFG.apiKey}`;
    document.getElementById('statusLine').textContent = 'è¿æ¥ä¸­...';
    ws = new WebSocket(wsUrl);

    ws.onopen = () => {
      ws.send(JSON.stringify({
        type: 'session.update',
        session: {
          modalities: ['audio', 'text'],
          voice: CFG.voice,
          instructions: buildSysPrompt(),
          input_audio_format: 'pcm16',
          output_audio_format: 'pcm16',
          turn_detection: { type: 'server_vad' },
          input_audio_transcription: { model: 'qwen3-asr-flash-realtime' }
        }
      }));
      isActive = true;
      document.getElementById('micBtn').classList.add('recording');
      document.getElementById('micBtn').textContent = 'â¹ï¸';
      document.getElementById('statusLine').textContent = 'ğŸ‘‚ ç›‘å¬ä¸­ï¼ˆæ”¯æŒåå°ï¼‰...';
      updateBadge();
      setAvatar('idle');
      // Start foreground service for background keep-alive
      if (window.NativeBridge) { try { window.NativeBridge.startKeepAlive(); } catch(e){} }

      micProcessor.onaudioprocess = (e) => {
        if (!ws || ws.readyState !== WebSocket.OPEN) return;
        const inp = e.inputBuffer.getChannelData(0);
        const ratio = audioCtx.sampleRate / 16000;
        const len = Math.floor(inp.length / ratio);
        const i16 = new Int16Array(len);
        for (let i = 0; i < len; i++) { const s = Math.max(-1, Math.min(1, inp[Math.floor(i * ratio)])); i16[i] = s < 0 ? s * 0x8000 : s * 0x7FFF; }
        ws.send(JSON.stringify({ type: 'input_audio_buffer.append', audio: ab2b64(i16.buffer) }));
        hasAudioSent = true;
      };
    };

    ws.onmessage = async (ev) => {
      if (typeof ev.data === 'string') {
        try { await handleMsg(JSON.parse(ev.data)); } catch {}
      } else {
        if (isGateOpen) playChunk(ev.data);
      }
    };
    ws.onerror = () => { document.getElementById('statusLine').textContent = 'âŒ è¿æ¥é”™è¯¯'; };
    ws.onclose = () => { if (isActive) stopSession(); };
  } catch (err) {
    document.getElementById('statusLine').textContent = 'âŒ ' + err.message;
  }
}

async function handleMsg(msg) {
  const t = msg.type || '';
  if (t === 'input_audio_buffer.speech_started') { clearAudio(); audioBuffer = []; isGateOpen = false; }
  else if (t === 'conversation.item.input_audio_transcription.completed') {
    const txt = (msg.transcript || '').trim(); if (!txt) return;
    mem.addObs(`ç”¨æˆ·: ${txt}`, 5);
    const decision = shouldRespond(txt);
    if (decision.respond) {
      addChat('user', txt); isGateOpen = true;
      if (decision.bye) { addChat('sys', 'ğŸ‘‹ å†è§'); setTimeout(deactivateSess, 1000); }
      else if (!decision.wake) consumeTurn();
      audioBuffer.forEach(c => playChunk(c)); audioBuffer = [];
    } else {
      addChat('sys', `[ç›‘å¬] ${txt}`); audioBuffer = [];
    }
  }
  else if (t === 'response.audio_transcript.done') {
    const txt = (msg.transcript || '').trim();
    if (txt && isGateOpen) { addChat('ai', txt); mem.addObs(`AI: ${txt}`, 5); }
    // Auto memory flush check
    if (mem.needsFlush()) autoFlush();
  }
  else if (t === 'response.audio.delta') {
    if (msg.delta) { const ab = b642ab(msg.delta); if (isGateOpen) playChunk(ab); else audioBuffer.push(ab); }
  }
}

function stopSession() {
  isActive = false; deactivateSess(); clearAudio(); setAvatar('idle');
  stopCamera(); hasAudioSent = false;
  // Stop foreground service
  if (window.NativeBridge) { try { window.NativeBridge.stopKeepAlive(); } catch(e){} }
  if (ws) { ws.onclose = null; ws.close(); ws = null; }
  if (micProcessor) { micProcessor.onaudioprocess = null; micProcessor.disconnect(); micProcessor = null; }
  if (micSource) { micSource.disconnect(); micSource = null; }
  if (micStream) { micStream.getTracks().forEach(t => t.stop()); micStream = null; }
  document.getElementById('micBtn').classList.remove('recording');
  document.getElementById('micBtn').textContent = 'ğŸ¤';
  document.getElementById('statusLine').textContent = 'å·²åœæ­¢';
}

// ---- Audio ----
function clearAudio() { activeSources.forEach(s => { try { s.stop(); } catch {} }); activeSources = []; if (audioCtx) nextPlayTime = audioCtx.currentTime; setAvatar('idle'); }
function playChunk(ab) {
  if (!audioCtx || !ab || ab.byteLength === 0) return;
  try {
    const i16 = new Int16Array(ab); const f32 = new Float32Array(i16.length);
    for (let i = 0; i < i16.length; i++) f32[i] = i16[i] / 32768.0;
    const buf = audioCtx.createBuffer(1, f32.length, 24000); buf.getChannelData(0).set(f32);
    const src = audioCtx.createBufferSource(); src.buffer = buf; src.connect(audioCtx.destination);
    if (nextPlayTime < audioCtx.currentTime) nextPlayTime = audioCtx.currentTime;
    src.start(nextPlayTime); nextPlayTime += buf.duration;
    setAvatar('talk'); activeSources.push(src);
    src.onended = () => { activeSources = activeSources.filter(s => s !== src); if (activeSources.length === 0) setAvatar('idle'); };
  } catch {}
}

// ---- Memory flush (OpenClaw pre-compaction pattern) ----
async function autoFlush() {
  const recent = mem.getRecent(20).map(m => m.text).join('\n');
  try {
    const resp = await fetch('https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${CFG.apiKey}` },
      body: JSON.stringify({ model: 'qwen-plus', messages: [{ role: 'user', content: `æ€»ç»“ä»¥ä¸‹å¯¹è¯è¦ç‚¹ï¼ˆ50å­—å†…ï¼‰ï¼š\n${recent}` }], max_tokens: 100 })
    });
    const data = await resp.json();
    const summary = data.choices?.[0]?.message?.content?.trim();
    if (summary) { mem.compact(summary); }
  } catch {}
}

async function manualFlush() {
  toast('æ­£åœ¨ç”Ÿæˆæ€»ç»“...');
  await autoFlush();
  renderMemory();
  toast('è®°å¿†å·²æ›´æ–°');
}

function exportMemory() {
  const data = mem.exportAll();
  const blob = new Blob([data], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a'); a.href = url; a.download = `memory_${new Date().toISOString().split('T')[0]}.json`; a.click();
  URL.revokeObjectURL(url);
  toast('è®°å¿†å·²å¯¼å‡º');
}

// ---- Render Memory ----
function renderMemory() {
  const recent = mem.getRecent(8);
  document.getElementById('shortMem').innerHTML = recent.length ? recent.map(m => `<div class="mem-entry"><span class="me-time">${m.time}</span> ${m.text}</div>`).join('') : 'æš‚æ— ';
  const lt = mem.getLongTerm();
  document.getElementById('longMem').innerHTML = lt.length ? lt.map(t => `<div class="mem-entry">${t}</div>`).join('') : 'æš‚æ— ';
  const refs = mem.reflections.slice(-5);
  document.getElementById('refMem').innerHTML = refs.length ? refs.map(m => `<div class="mem-entry"><span class="me-time">${m.time}</span> ${m.text}</div>`).join('') : 'æš‚æ— ';
  const s = mem.getStats();
  document.getElementById('msObs').textContent = s.obs;
  document.getElementById('msDays').textContent = s.days;
  document.getElementById('msRef').textContent = s.refs;
}

// ---- Cards ----
async function generateCard() {
  const recent = mem.getRecent(15).map(m => m.text).join('\n');
  const longTermCtx = mem.getLongTerm().join('\n');
  const imageCtx = lastImageContext ? `\n\næœ€è¿‘åˆ†æçš„å›¾ç‰‡å†…å®¹ï¼š${lastImageContext}` : '';
  if (!recent && !longTermCtx) { toast('æš‚æ— å¯¹è¯å†…å®¹'); return; }
  toast('AI æ­£åœ¨ç”Ÿæˆå¡ç‰‡...');
  try {
    const resp = await fetch('https://dashscope.aliyuncs.com/compatible-mode/v1/chat/completions', {
      method: 'POST',
      headers: { 'Content-Type': 'application/json', 'Authorization': `Bearer ${CFG.apiKey}` },
      body: JSON.stringify({
        model: 'qwen-plus',
        messages: [{ role: 'user', content: `æ ¹æ®ä»¥ä¸‹å¯¹è¯å’Œè®°å¿†ï¼Œç”Ÿæˆä¸€å¼ çŸ¥è¯†å¡ç‰‡ï¼ŒJSONæ ¼å¼ï¼š{"title":"æ ‡é¢˜","body":"å†…å®¹è¦ç‚¹(100å­—å†…)","tags":["æ ‡ç­¾1","æ ‡ç­¾2"]}\n\n## è¿‘æœŸå¯¹è¯\n${recent}\n\n## é•¿æœŸè®°å¿†\n${longTermCtx || 'æš‚æ— '}${imageCtx}` }],
        max_tokens: 200
      })
    });
    const data = await resp.json();
    const raw = data.choices?.[0]?.message?.content?.trim();
    const parsed = JSON.parse(raw.replace(/```json\n?/g, '').replace(/```/g, ''));
    const card = { id: Date.now(), time: fmtDate(new Date()), title: parsed.title || 'å¡ç‰‡', body: parsed.body || '', tags: parsed.tags || [] };
    cards.unshift(card);
    localStorage.setItem('av_cards', JSON.stringify(cards));
    renderCards();
    toast('å¡ç‰‡å·²ç”Ÿæˆ');
  } catch (e) { toast('ç”Ÿæˆå¤±è´¥: ' + e.message); }
}

function renderCards() {
  const grid = document.getElementById('cardsGrid');
  grid.innerHTML = cards.length ? cards.map(c => `
    <div class="card-item">
      <div class="card-time">${c.time}</div>
      <div class="card-title">${c.title}</div>
      <div class="card-body">${c.body}</div>
      <div class="card-tags">${(c.tags || []).map(t => `<span class="tag">${t}</span>`).join('')}</div>
      <div class="card-actions">
        <button onclick="saveCardAsImage(${c.id})">ğŸ“· å­˜ä¸ºå›¾ç‰‡</button>
        <button onclick="deleteCard(${c.id})">ğŸ—‘ï¸ åˆ é™¤</button>
      </div>
    </div>`).join('') : '<div style="color:var(--text3);font-size:13px;text-align:center;padding:40px">ç‚¹å‡»ä¸Šæ–¹æŒ‰é’®ï¼ŒAI ä¼šæ ¹æ®å¯¹è¯ç”ŸæˆçŸ¥è¯†å¡ç‰‡</div>';
}

function deleteCard(id) { cards = cards.filter(c => c.id !== id); localStorage.setItem('av_cards', JSON.stringify(cards)); renderCards(); }
function clearCards() { cards = []; localStorage.setItem('av_cards', '[]'); renderCards(); toast('å¡ç‰‡å·²æ¸…ç©º'); }

function saveCardAsImage(id) {
  const card = cards.find(c => c.id === id); if (!card) return;
  const canvas = document.getElementById('saveCanvas');
  const ctx = canvas.getContext('2d');
  canvas.width = 600; canvas.height = 400;
  // Background
  const grad = ctx.createLinearGradient(0, 0, 600, 400);
  grad.addColorStop(0, '#1a1a2e'); grad.addColorStop(1, '#16213e');
  ctx.fillStyle = grad; ctx.fillRect(0, 0, 600, 400);
  // Border
  ctx.fillStyle = '#6c9fff'; ctx.fillRect(0, 0, 4, 400);
  // Title
  ctx.fillStyle = '#e6edf3'; ctx.font = 'bold 22px system-ui'; ctx.fillText(card.title, 24, 50);
  // Time
  ctx.fillStyle = '#8b949e'; ctx.font = '12px system-ui'; ctx.fillText(card.time, 24, 75);
  // Body
  ctx.fillStyle = '#c9d1d9'; ctx.font = '15px system-ui';
  const lines = wrapText(ctx, card.body, 550);
  lines.forEach((line, i) => ctx.fillText(line, 24, 110 + i * 24));
  // Tags
  const tagY = 110 + lines.length * 24 + 20;
  let tagX = 24;
  (card.tags || []).forEach(tag => {
    ctx.fillStyle = 'rgba(108,159,255,.2)'; const tw = ctx.measureText(tag).width + 16;
    ctx.beginPath(); ctx.roundRect(tagX, tagY - 12, tw, 22, 10); ctx.fill();
    ctx.fillStyle = '#6c9fff'; ctx.font = '12px system-ui'; ctx.fillText(tag, tagX + 8, tagY + 4);
    tagX += tw + 8;
  });
  // Watermark
  ctx.fillStyle = '#484f58'; ctx.font = '10px system-ui'; ctx.fillText('AI Avatar Â· ' + new Date().toLocaleDateString(), 24, 380);

  // Convert to data URL and open in new tab (works in Android WebView)
  const dataUrl = canvas.toDataURL('image/png');
  // Try download link first
  const a = document.createElement('a'); a.href = dataUrl; a.download = `card_${card.id}.png`;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  // Also show as viewable image so user can long-press to save on mobile
  const win = window.open('');
  if (win) {
    win.document.write(`<html><head><title>å¡ç‰‡å›¾ç‰‡</title><meta name="viewport" content="width=device-width,initial-scale=1"></head><body style="margin:0;background:#000;display:flex;align-items:center;justify-content:center;min-height:100vh"><img src="${dataUrl}" style="max-width:100%;height:auto"/><p style="color:#fff;text-align:center;font-size:14px;padding:10px">é•¿æŒ‰å›¾ç‰‡å¯ä¿å­˜åˆ°ç›¸å†Œ</p></body></html>`);
    win.document.close();
  }
  toast('é•¿æŒ‰å›¾ç‰‡å¯ä¿å­˜åˆ°ç›¸å†Œ');
}

function wrapText(ctx, text, maxW) {
  const words = text.split(''); const lines = []; let line = '';
  for (const ch of words) {
    const test = line + ch;
    if (ctx.measureText(test).width > maxW) { lines.push(line); line = ch; }
    else line = test;
  }
  if (line) lines.push(line);
  return lines.slice(0, 10);
}

// ---- Utils ----
function ab2b64(buf) { const b = new Uint8Array(buf); let s = ''; for (let i = 0; i < b.length; i++) s += String.fromCharCode(b[i]); return btoa(s); }
function b642ab(b64) { const s = atob(b64); const b = new Uint8Array(s.length); for (let i = 0; i < s.length; i++) b[i] = s.charCodeAt(i); return b.buffer; }
function toast(msg) { const t = document.getElementById('toast'); t.textContent = msg; t.classList.add('show'); setTimeout(() => t.classList.remove('show'), 2000); }
</script>
</body>
</html>
